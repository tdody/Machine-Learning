
% Default to the notebook output style

    


% Inherit from the specified cell style.




    
\documentclass[11pt]{article}

    
    
    \usepackage[T1]{fontenc}
    % Nicer default font (+ math font) than Computer Modern for most use cases
    \usepackage{mathpazo}

    % Basic figure setup, for now with no caption control since it's done
    % automatically by Pandoc (which extracts ![](path) syntax from Markdown).
    \usepackage{graphicx}
    % We will generate all images so they have a width \maxwidth. This means
    % that they will get their normal width if they fit onto the page, but
    % are scaled down if they would overflow the margins.
    \makeatletter
    \def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth
    \else\Gin@nat@width\fi}
    \makeatother
    \let\Oldincludegraphics\includegraphics
    % Set max figure width to be 80% of text width, for now hardcoded.
    \renewcommand{\includegraphics}[1]{\Oldincludegraphics[width=.8\maxwidth]{#1}}
    % Ensure that by default, figures have no caption (until we provide a
    % proper Figure object with a Caption API and a way to capture that
    % in the conversion process - todo).
    \usepackage{caption}
    \DeclareCaptionLabelFormat{nolabel}{}
    \captionsetup{labelformat=nolabel}

    \usepackage{adjustbox} % Used to constrain images to a maximum size 
    \usepackage{xcolor} % Allow colors to be defined
    \usepackage{enumerate} % Needed for markdown enumerations to work
    \usepackage{geometry} % Used to adjust the document margins
    \usepackage{amsmath} % Equations
    \usepackage{amssymb} % Equations
    \usepackage{textcomp} % defines textquotesingle
    % Hack from http://tex.stackexchange.com/a/47451/13684:
    \AtBeginDocument{%
        \def\PYZsq{\textquotesingle}% Upright quotes in Pygmentized code
    }
    \usepackage{upquote} % Upright quotes for verbatim code
    \usepackage{eurosym} % defines \euro
    \usepackage[mathletters]{ucs} % Extended unicode (utf-8) support
    \usepackage[utf8x]{inputenc} % Allow utf-8 characters in the tex document
    \usepackage{fancyvrb} % verbatim replacement that allows latex
    \usepackage{grffile} % extends the file name processing of package graphics 
                         % to support a larger range 
    % The hyperref package gives us a pdf with properly built
    % internal navigation ('pdf bookmarks' for the table of contents,
    % internal cross-reference links, web links for URLs, etc.)
    \usepackage{hyperref}
    \usepackage{longtable} % longtable support required by pandoc >1.10
    \usepackage{booktabs}  % table support for pandoc > 1.12.2
    \usepackage[inline]{enumitem} % IRkernel/repr support (it uses the enumerate* environment)
    \usepackage[normalem]{ulem} % ulem is needed to support strikethroughs (\sout)
                                % normalem makes italics be italics, not underlines
    

    
    
    % Colors for the hyperref package
    \definecolor{urlcolor}{rgb}{0,.145,.698}
    \definecolor{linkcolor}{rgb}{.71,0.21,0.01}
    \definecolor{citecolor}{rgb}{.12,.54,.11}

    % ANSI colors
    \definecolor{ansi-black}{HTML}{3E424D}
    \definecolor{ansi-black-intense}{HTML}{282C36}
    \definecolor{ansi-red}{HTML}{E75C58}
    \definecolor{ansi-red-intense}{HTML}{B22B31}
    \definecolor{ansi-green}{HTML}{00A250}
    \definecolor{ansi-green-intense}{HTML}{007427}
    \definecolor{ansi-yellow}{HTML}{DDB62B}
    \definecolor{ansi-yellow-intense}{HTML}{B27D12}
    \definecolor{ansi-blue}{HTML}{208FFB}
    \definecolor{ansi-blue-intense}{HTML}{0065CA}
    \definecolor{ansi-magenta}{HTML}{D160C4}
    \definecolor{ansi-magenta-intense}{HTML}{A03196}
    \definecolor{ansi-cyan}{HTML}{60C6C8}
    \definecolor{ansi-cyan-intense}{HTML}{258F8F}
    \definecolor{ansi-white}{HTML}{C5C1B4}
    \definecolor{ansi-white-intense}{HTML}{A1A6B2}

    % commands and environments needed by pandoc snippets
    % extracted from the output of `pandoc -s`
    \providecommand{\tightlist}{%
      \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
    \DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
    % Add ',fontsize=\small' for more characters per line
    \newenvironment{Shaded}{}{}
    \newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{{#1}}}
    \newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{{#1}}}}
    \newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{{#1}}}
    \newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{{#1}}}
    \newcommand{\RegionMarkerTok}[1]{{#1}}
    \newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\NormalTok}[1]{{#1}}
    
    % Additional commands for more recent versions of Pandoc
    \newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{{#1}}}
    \newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{{#1}}}
    \newcommand{\ImportTok}[1]{{#1}}
    \newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{{#1}}}}
    \newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{{#1}}}
    \newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{{#1}}}
    \newcommand{\BuiltInTok}[1]{{#1}}
    \newcommand{\ExtensionTok}[1]{{#1}}
    \newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{{#1}}}
    \newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{{#1}}}
    \newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    
    
    % Define a nice break command that doesn't care if a line doesn't already
    % exist.
    \def\br{\hspace*{\fill} \\* }
    % Math Jax compatability definitions
    \def\gt{>}
    \def\lt{<}
    % Document parameters
    \title{Tensorflow+Tutorial}
    
    
    

    % Pygments definitions
    
\makeatletter
\def\PY@reset{\let\PY@it=\relax \let\PY@bf=\relax%
    \let\PY@ul=\relax \let\PY@tc=\relax%
    \let\PY@bc=\relax \let\PY@ff=\relax}
\def\PY@tok#1{\csname PY@tok@#1\endcsname}
\def\PY@toks#1+{\ifx\relax#1\empty\else%
    \PY@tok{#1}\expandafter\PY@toks\fi}
\def\PY@do#1{\PY@bc{\PY@tc{\PY@ul{%
    \PY@it{\PY@bf{\PY@ff{#1}}}}}}}
\def\PY#1#2{\PY@reset\PY@toks#1+\relax+\PY@do{#2}}

\expandafter\def\csname PY@tok@gd\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@gu\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@gt\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PY@tok@gs\endcsname{\let\PY@bf=\textbf}
\expandafter\def\csname PY@tok@gr\endcsname{\def\PY@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@cm\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@vg\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@vi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@vm\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@mh\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@cs\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@ge\endcsname{\let\PY@it=\textit}
\expandafter\def\csname PY@tok@vc\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@il\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@go\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.53,0.53,0.53}{##1}}}
\expandafter\def\csname PY@tok@cp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.74,0.48,0.00}{##1}}}
\expandafter\def\csname PY@tok@gi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PY@tok@gh\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@ni\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.60,0.60,0.60}{##1}}}
\expandafter\def\csname PY@tok@nl\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.63,0.63,0.00}{##1}}}
\expandafter\def\csname PY@tok@nn\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@no\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.53,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@na\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.49,0.56,0.16}{##1}}}
\expandafter\def\csname PY@tok@nb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@nc\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@nd\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\expandafter\def\csname PY@tok@ne\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.82,0.25,0.23}{##1}}}
\expandafter\def\csname PY@tok@nf\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@si\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\expandafter\def\csname PY@tok@s2\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@nt\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@nv\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@s1\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@dl\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@ch\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@m\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@gp\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@sh\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@ow\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\expandafter\def\csname PY@tok@sx\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@bp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@c1\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@fm\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@o\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@kc\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@c\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@mf\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@err\endcsname{\def\PY@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PY@tok@mb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@ss\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@sr\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\expandafter\def\csname PY@tok@mo\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@kd\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@mi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@kn\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@cpf\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@kr\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@s\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@kp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@w\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PY@tok@kt\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.69,0.00,0.25}{##1}}}
\expandafter\def\csname PY@tok@sc\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sa\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@k\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@se\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.13}{##1}}}
\expandafter\def\csname PY@tok@sd\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}

\def\PYZbs{\char`\\}
\def\PYZus{\char`\_}
\def\PYZob{\char`\{}
\def\PYZcb{\char`\}}
\def\PYZca{\char`\^}
\def\PYZam{\char`\&}
\def\PYZlt{\char`\<}
\def\PYZgt{\char`\>}
\def\PYZsh{\char`\#}
\def\PYZpc{\char`\%}
\def\PYZdl{\char`\$}
\def\PYZhy{\char`\-}
\def\PYZsq{\char`\'}
\def\PYZdq{\char`\"}
\def\PYZti{\char`\~}
% for compatibility with earlier versions
\def\PYZat{@}
\def\PYZlb{[}
\def\PYZrb{]}
\makeatother


    % Exact colors from NB
    \definecolor{incolor}{rgb}{0.0, 0.0, 0.5}
    \definecolor{outcolor}{rgb}{0.545, 0.0, 0.0}



    
    % Prevent overflowing lines due to hard-to-break entities
    \sloppy 
    % Setup hyperref package
    \hypersetup{
      breaklinks=true,  % so long urls are correctly broken across lines
      colorlinks=true,
      urlcolor=urlcolor,
      linkcolor=linkcolor,
      citecolor=citecolor,
      }
    % Slightly bigger margins than the latex defaults
    
    \geometry{verbose,tmargin=1in,bmargin=1in,lmargin=1in,rmargin=1in}
    
    

    \begin{document}
    
    
    \maketitle
    
    

    
    \section{TensorFlow Tutorial}\label{tensorflow-tutorial}

Welcome to this week's programming assignment. Until now, you've always
used numpy to build neural networks. Now we will step you through a deep
learning framework that will allow you to build neural networks more
easily. Machine learning frameworks like TensorFlow, PaddlePaddle,
Torch, Caffe, Keras, and many others can speed up your machine learning
development significantly. All of these frameworks also have a lot of
documentation, which you should feel free to read. In this assignment,
you will learn to do the following in TensorFlow:

\begin{itemize}
\tightlist
\item
  Initialize variables
\item
  Start your own session
\item
  Train algorithms
\item
  Implement a Neural Network
\end{itemize}

Programing frameworks can not only shorten your coding time, but
sometimes also perform optimizations that speed up your code.

\subsection{1 - Exploring the Tensorflow
Library}\label{exploring-the-tensorflow-library}

To start, you will import the library:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}1}]:} \PY{k+kn}{import} \PY{n+nn}{math}
        \PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k+kn}{as} \PY{n+nn}{np}
        \PY{k+kn}{import} \PY{n+nn}{h5py}
        \PY{k+kn}{import} \PY{n+nn}{matplotlib.pyplot} \PY{k+kn}{as} \PY{n+nn}{plt}
        \PY{k+kn}{import} \PY{n+nn}{tensorflow} \PY{k+kn}{as} \PY{n+nn}{tf}
        \PY{k+kn}{from} \PY{n+nn}{tensorflow.python.framework} \PY{k+kn}{import} \PY{n}{ops}
        \PY{k+kn}{from} \PY{n+nn}{tf\PYZus{}utils} \PY{k+kn}{import} \PY{n}{load\PYZus{}dataset}\PY{p}{,} \PY{n}{random\PYZus{}mini\PYZus{}batches}\PY{p}{,} \PY{n}{convert\PYZus{}to\PYZus{}one\PYZus{}hot}\PY{p}{,} \PY{n}{predict}
        
        \PY{o}{\PYZpc{}}\PY{k}{matplotlib} inline
        \PY{n}{np}\PY{o}{.}\PY{n}{random}\PY{o}{.}\PY{n}{seed}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{)}
\end{Verbatim}

    Now that you have imported the library, we will walk you through its
different applications. You will start with an example, where we compute
for you the loss of one training example.
\[loss = \mathcal{L}(\hat{y}, y) = (\hat y^{(i)} - y^{(i)})^2 \tag{1}\]

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}2}]:} \PY{n}{y\PYZus{}hat} \PY{o}{=} \PY{n}{tf}\PY{o}{.}\PY{n}{constant}\PY{p}{(}\PY{l+m+mi}{36}\PY{p}{,} \PY{n}{name}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{y\PYZus{}hat}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}            \PY{c+c1}{\PYZsh{} Define y\PYZus{}hat constant. Set to 36.}
        \PY{n}{y} \PY{o}{=} \PY{n}{tf}\PY{o}{.}\PY{n}{constant}\PY{p}{(}\PY{l+m+mi}{39}\PY{p}{,} \PY{n}{name}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{y}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}                    \PY{c+c1}{\PYZsh{} Define y. Set to 39}
        
        \PY{n}{loss} \PY{o}{=} \PY{n}{tf}\PY{o}{.}\PY{n}{Variable}\PY{p}{(}\PY{p}{(}\PY{n}{y} \PY{o}{\PYZhy{}} \PY{n}{y\PYZus{}hat}\PY{p}{)}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2}\PY{p}{,} \PY{n}{name}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{loss}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}  \PY{c+c1}{\PYZsh{} Create a variable for the loss}
        
        \PY{n}{init} \PY{o}{=} \PY{n}{tf}\PY{o}{.}\PY{n}{global\PYZus{}variables\PYZus{}initializer}\PY{p}{(}\PY{p}{)}         \PY{c+c1}{\PYZsh{} When init is run later (session.run(init)),}
                                                         \PY{c+c1}{\PYZsh{} the loss variable will be initialized and ready to be computed}
        \PY{k}{with} \PY{n}{tf}\PY{o}{.}\PY{n}{Session}\PY{p}{(}\PY{p}{)} \PY{k}{as} \PY{n}{session}\PY{p}{:}                    \PY{c+c1}{\PYZsh{} Create a session and print the output}
            \PY{n}{session}\PY{o}{.}\PY{n}{run}\PY{p}{(}\PY{n}{init}\PY{p}{)}                            \PY{c+c1}{\PYZsh{} Initializes the variables}
            \PY{k}{print}\PY{p}{(}\PY{n}{session}\PY{o}{.}\PY{n}{run}\PY{p}{(}\PY{n}{loss}\PY{p}{)}\PY{p}{)}                     \PY{c+c1}{\PYZsh{} Prints the loss}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
9

    \end{Verbatim}

    Writing and running programs in TensorFlow has the following steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create Tensors (variables) that are not yet executed/evaluated.
\item
  Write operations between those Tensors.
\item
  Initialize your Tensors.
\item
  Create a Session.
\item
  Run the Session. This will run the operations you'd written above.
\end{enumerate}

Therefore, when we created a variable for the loss, we simply defined
the loss as a function of other quantities, but did not evaluate its
value. To evaluate it, we had to run
\texttt{init=tf.global\_variables\_initializer()}. That initialized the
loss variable, and in the last line we were finally able to evaluate the
value of \texttt{loss} and print its value.

Now let us look at an easy example. Run the cell below:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}3}]:} \PY{n}{a} \PY{o}{=} \PY{n}{tf}\PY{o}{.}\PY{n}{constant}\PY{p}{(}\PY{l+m+mi}{2}\PY{p}{)}
        \PY{n}{b} \PY{o}{=} \PY{n}{tf}\PY{o}{.}\PY{n}{constant}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{)}
        \PY{n}{c} \PY{o}{=} \PY{n}{tf}\PY{o}{.}\PY{n}{multiply}\PY{p}{(}\PY{n}{a}\PY{p}{,}\PY{n}{b}\PY{p}{)}
        \PY{k}{print}\PY{p}{(}\PY{n}{c}\PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Tensor("Mul:0", shape=(), dtype=int32)

    \end{Verbatim}

    As expected, you will not see 20! You got a tensor saying that the
result is a tensor that does not have the shape attribute, and is of
type "int32". All you did was put in the 'computation graph', but you
have not run this computation yet. In order to actually multiply the two
numbers, you will have to create a session and run it.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}4}]:} \PY{n}{sess} \PY{o}{=} \PY{n}{tf}\PY{o}{.}\PY{n}{Session}\PY{p}{(}\PY{p}{)}
        \PY{k}{print}\PY{p}{(}\PY{n}{sess}\PY{o}{.}\PY{n}{run}\PY{p}{(}\PY{n}{c}\PY{p}{)}\PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
20

    \end{Verbatim}

    Great! To summarize, \textbf{remember to initialize your variables,
create a session and run the operations inside the session}.

Next, you'll also have to know about placeholders. A placeholder is an
object whose value you can specify only later. To specify values for a
placeholder, you can pass in values by using a "feed dictionary"
(\texttt{feed\_dict} variable). Below, we created a placeholder for x.
This allows us to pass in a number later when we run the session.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}5}]:} \PY{c+c1}{\PYZsh{} Change the value of x in the feed\PYZus{}dict}
        
        \PY{n}{x} \PY{o}{=} \PY{n}{tf}\PY{o}{.}\PY{n}{placeholder}\PY{p}{(}\PY{n}{tf}\PY{o}{.}\PY{n}{int64}\PY{p}{,} \PY{n}{name} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{x}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{k}{print}\PY{p}{(}\PY{n}{sess}\PY{o}{.}\PY{n}{run}\PY{p}{(}\PY{l+m+mi}{2} \PY{o}{*} \PY{n}{x}\PY{p}{,} \PY{n}{feed\PYZus{}dict} \PY{o}{=} \PY{p}{\PYZob{}}\PY{n}{x}\PY{p}{:} \PY{l+m+mi}{3}\PY{p}{\PYZcb{}}\PY{p}{)}\PY{p}{)}
        \PY{n}{sess}\PY{o}{.}\PY{n}{close}\PY{p}{(}\PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
6

    \end{Verbatim}

    When you first defined \texttt{x} you did not have to specify a value
for it. A placeholder is simply a variable that you will assign data to
only later, when running the session. We say that you \textbf{feed data}
to these placeholders when running the session.

Here's what's happening: When you specify the operations needed for a
computation, you are telling TensorFlow how to construct a computation
graph. The computation graph can have some placeholders whose values you
will specify only later. Finally, when you run the session, you are
telling TensorFlow to execute the computation graph.

    \subsubsection{1.1 - Linear function}\label{linear-function}

Lets start this programming exercise by computing the following
equation: \(Y = WX + b\), where \(W\) and \(X\) are random matrices and
b is a random vector.

\textbf{Exercise}: Compute \(WX + b\) where \(W, X\), and \(b\) are
drawn from a random normal distribution. W is of shape (4, 3), X is
(3,1) and b is (4,1). As an example, here is how you would define a
constant X that has shape (3,1):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{X }\OperatorTok{=}\NormalTok{ tf.constant(np.random.randn(}\DecValTok{3}\NormalTok{,}\DecValTok{1}\NormalTok{), name }\OperatorTok{=} \StringTok{"X"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

You might find the following functions helpful: - tf.matmul(..., ...) to
do a matrix multiplication - tf.add(..., ...) to do an addition -
np.random.randn(...) to initialize randomly

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}8}]:} \PY{c+c1}{\PYZsh{} GRADED FUNCTION: linear\PYZus{}function}
        
        \PY{k}{def} \PY{n+nf}{linear\PYZus{}function}\PY{p}{(}\PY{p}{)}\PY{p}{:}
            \PY{l+s+sd}{\PYZdq{}\PYZdq{}\PYZdq{}}
        \PY{l+s+sd}{    Implements a linear function: }
        \PY{l+s+sd}{            Initializes W to be a random tensor of shape (4,3)}
        \PY{l+s+sd}{            Initializes X to be a random tensor of shape (3,1)}
        \PY{l+s+sd}{            Initializes b to be a random tensor of shape (4,1)}
        \PY{l+s+sd}{    Returns: }
        \PY{l+s+sd}{    result \PYZhy{}\PYZhy{} runs the session for Y = WX + b }
        \PY{l+s+sd}{    \PYZdq{}\PYZdq{}\PYZdq{}}
            
            \PY{n}{np}\PY{o}{.}\PY{n}{random}\PY{o}{.}\PY{n}{seed}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{)}
            
            \PY{c+c1}{\PYZsh{}\PYZsh{}\PYZsh{} START CODE HERE \PYZsh{}\PYZsh{}\PYZsh{} (4 lines of code)}
            \PY{n}{X} \PY{o}{=} \PY{n}{tf}\PY{o}{.}\PY{n}{constant}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{random}\PY{o}{.}\PY{n}{randn}\PY{p}{(}\PY{l+m+mi}{3}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{)}\PY{p}{,} \PY{n}{name} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{X}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
            \PY{n}{W} \PY{o}{=} \PY{n}{tf}\PY{o}{.}\PY{n}{constant}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{random}\PY{o}{.}\PY{n}{randn}\PY{p}{(}\PY{l+m+mi}{4}\PY{p}{,}\PY{l+m+mi}{3}\PY{p}{)}\PY{p}{,} \PY{n}{name} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{W}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
            \PY{n}{b} \PY{o}{=} \PY{n}{tf}\PY{o}{.}\PY{n}{constant}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{random}\PY{o}{.}\PY{n}{randn}\PY{p}{(}\PY{l+m+mi}{4}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{)}\PY{p}{,} \PY{n}{name} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{b}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
            \PY{n}{Y} \PY{o}{=} \PY{n}{tf}\PY{o}{.}\PY{n}{add}\PY{p}{(}\PY{n}{tf}\PY{o}{.}\PY{n}{matmul}\PY{p}{(}\PY{n}{W}\PY{p}{,}\PY{n}{X}\PY{p}{)}\PY{p}{,}\PY{n}{b}\PY{p}{)}
            \PY{c+c1}{\PYZsh{}\PYZsh{}\PYZsh{} END CODE HERE \PYZsh{}\PYZsh{}\PYZsh{} }
            
            \PY{c+c1}{\PYZsh{} Create the session using tf.Session() and run it with sess.run(...) on the variable you want to calculate}
            
            \PY{c+c1}{\PYZsh{}\PYZsh{}\PYZsh{} START CODE HERE \PYZsh{}\PYZsh{}\PYZsh{}}
            \PY{n}{sess} \PY{o}{=} \PY{n}{tf}\PY{o}{.}\PY{n}{Session}\PY{p}{(}\PY{p}{)}
            \PY{n}{result} \PY{o}{=} \PY{n}{sess}\PY{o}{.}\PY{n}{run}\PY{p}{(}\PY{n}{Y}\PY{p}{)}
            \PY{c+c1}{\PYZsh{}\PYZsh{}\PYZsh{} END CODE HERE \PYZsh{}\PYZsh{}\PYZsh{} }
            
            \PY{c+c1}{\PYZsh{} close the session }
            \PY{n}{sess}\PY{o}{.}\PY{n}{close}\PY{p}{(}\PY{p}{)}
        
            \PY{k}{return} \PY{n}{result}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}9}]:} \PY{k}{print}\PY{p}{(} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{result = }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{linear\PYZus{}function}\PY{p}{(}\PY{p}{)}\PY{p}{)}\PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
result = [[-2.15657382]
 [ 2.95891446]
 [-1.08926781]
 [-0.84538042]]

    \end{Verbatim}

    *** Expected Output ***:

\textbf{result}

{[}{[}-2.15657382{]}{[} 2.95891446{]}
{[}-1.08926781{]}{[}-0.84538042{]}{]}

    \subsubsection{1.2 - Computing the sigmoid}\label{computing-the-sigmoid}

Great! You just implemented a linear function. Tensorflow offers a
variety of commonly used neural network functions like
\texttt{tf.sigmoid} and \texttt{tf.softmax}. For this exercise lets
compute the sigmoid function of an input.

You will do this exercise using a placeholder variable \texttt{x}. When
running the session, you should use the feed dictionary to pass in the
input \texttt{z}. In this exercise, you will have to (i) create a
placeholder \texttt{x}, (ii) define the operations needed to compute the
sigmoid using \texttt{tf.sigmoid}, and then (iii) run the session.

** Exercise **: Implement the sigmoid function below. You should use the
following:

\begin{itemize}
\tightlist
\item
  \texttt{tf.placeholder(tf.float32,\ name\ =\ "...")}
\item
  \texttt{tf.sigmoid(...)}
\item
  \texttt{sess.run(...,\ feed\_dict\ =\ \{x:\ z\})}
\end{itemize}

Note that there are two typical ways to create and use sessions in
tensorflow:

\textbf{Method 1:}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sess }\OperatorTok{=}\NormalTok{ tf.Session()}
\CommentTok{# Run the variables initialization (if needed), run the operations}
\NormalTok{result }\OperatorTok{=}\NormalTok{ sess.run(..., feed_dict }\OperatorTok{=}\NormalTok{ \{...\})}
\NormalTok{sess.close() }\CommentTok{# Close the session}
\end{Highlighting}
\end{Shaded}

\textbf{Method 2:}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{with}\NormalTok{ tf.Session() }\ImportTok{as}\NormalTok{ sess: }
    \CommentTok{# run the variables initialization (if needed), run the operations}
\NormalTok{    result }\OperatorTok{=}\NormalTok{ sess.run(..., feed_dict }\OperatorTok{=}\NormalTok{ \{...\})}
    \CommentTok{# This takes care of closing the session for you :)}
\end{Highlighting}
\end{Shaded}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}14}]:} \PY{c+c1}{\PYZsh{} GRADED FUNCTION: sigmoid}
         
         \PY{k}{def} \PY{n+nf}{sigmoid}\PY{p}{(}\PY{n}{z}\PY{p}{)}\PY{p}{:}
             \PY{l+s+sd}{\PYZdq{}\PYZdq{}\PYZdq{}}
         \PY{l+s+sd}{    Computes the sigmoid of z}
         \PY{l+s+sd}{    }
         \PY{l+s+sd}{    Arguments:}
         \PY{l+s+sd}{    z \PYZhy{}\PYZhy{} input value, scalar or vector}
         \PY{l+s+sd}{    }
         \PY{l+s+sd}{    Returns: }
         \PY{l+s+sd}{    results \PYZhy{}\PYZhy{} the sigmoid of z}
         \PY{l+s+sd}{    \PYZdq{}\PYZdq{}\PYZdq{}}
             
             \PY{c+c1}{\PYZsh{}\PYZsh{}\PYZsh{} START CODE HERE \PYZsh{}\PYZsh{}\PYZsh{} ( approx. 4 lines of code)}
             \PY{c+c1}{\PYZsh{} Create a placeholder for x. Name it \PYZsq{}x\PYZsq{}.}
             \PY{n}{x} \PY{o}{=} \PY{n}{tf}\PY{o}{.}\PY{n}{placeholder}\PY{p}{(}\PY{n}{tf}\PY{o}{.}\PY{n}{float32}\PY{p}{,}\PY{n}{name} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{x}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         
             \PY{c+c1}{\PYZsh{} compute sigmoid(x)}
             \PY{n}{sigmoid} \PY{o}{=} \PY{n}{tf}\PY{o}{.}\PY{n}{sigmoid}\PY{p}{(}\PY{n}{x}\PY{p}{)}
         
             \PY{c+c1}{\PYZsh{} Create a session, and run it. Please use the method 2 explained above. }
             \PY{c+c1}{\PYZsh{} You should use a feed\PYZus{}dict to pass z\PYZsq{}s value to x. }
             \PY{k}{with} \PY{n}{tf}\PY{o}{.}\PY{n}{Session}\PY{p}{(}\PY{p}{)} \PY{k}{as} \PY{n}{sess}\PY{p}{:}
                 \PY{c+c1}{\PYZsh{} Run session and call the output \PYZdq{}result\PYZdq{}}
                 \PY{n}{result} \PY{o}{=} \PY{n}{sess}\PY{o}{.}\PY{n}{run}\PY{p}{(}\PY{n}{sigmoid}\PY{p}{,}\PY{n}{feed\PYZus{}dict}\PY{o}{=}\PY{p}{\PYZob{}}\PY{n}{x}\PY{p}{:}\PY{n}{z}\PY{p}{\PYZcb{}}\PY{p}{)}
             
             \PY{c+c1}{\PYZsh{}\PYZsh{}\PYZsh{} END CODE HERE \PYZsh{}\PYZsh{}\PYZsh{}}
             
             \PY{k}{return} \PY{n}{result}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}15}]:} \PY{k}{print} \PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{sigmoid(0) = }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{sigmoid}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{)}\PY{p}{)}\PY{p}{)}
         \PY{k}{print} \PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{sigmoid(12) = }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{sigmoid}\PY{p}{(}\PY{l+m+mi}{12}\PY{p}{)}\PY{p}{)}\PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
sigmoid(0) = 0.5
sigmoid(12) = 0.999994

    \end{Verbatim}

    *** Expected Output ***:

\textbf{sigmoid(0)}

0.5

\textbf{sigmoid(12)}

0.999994

     \textbf{To summarize, you how know how to}: 1. Create placeholders 2.
Specify the computation graph corresponding to operations you want to
compute 3. Create the session 4. Run the session, using a feed
dictionary if necessary to specify placeholder variables' values.

    \subsubsection{1.3 - Computing the Cost}\label{computing-the-cost}

You can also use a built-in function to compute the cost of your neural
network. So instead of needing to write code to compute this as a
function of \(a^{[2](i)}\) and \(y^{(i)}\) for i=1...m:
\[ J = - \frac{1}{m}  \sum_{i = 1}^m  \large ( \small y^{(i)} \log a^{ [2] (i)} + (1-y^{(i)})\log (1-a^{ [2] (i)} )\large )\small\tag{2}\]

you can do it in one line of code in tensorflow!

\textbf{Exercise}: Implement the cross entropy loss. The function you
will use is:

\begin{itemize}
\tightlist
\item
  \texttt{tf.nn.sigmoid\_cross\_entropy\_with\_logits(logits\ =\ ...,\ \ labels\ =\ ...)}
\end{itemize}

Your code should input \texttt{z}, compute the sigmoid (to get
\texttt{a}) and then compute the cross entropy cost \(J\). All this can
be done using one call to
\texttt{tf.nn.sigmoid\_cross\_entropy\_with\_logits}, which computes

\[- \frac{1}{m}  \sum_{i = 1}^m  \large ( \small y^{(i)} \log \sigma(z^{[2](i)}) + (1-y^{(i)})\log (1-\sigma(z^{[2](i)})\large )\small\tag{2}\]

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}16}]:} \PY{c+c1}{\PYZsh{} GRADED FUNCTION: cost}
         
         \PY{k}{def} \PY{n+nf}{cost}\PY{p}{(}\PY{n}{logits}\PY{p}{,} \PY{n}{labels}\PY{p}{)}\PY{p}{:}
             \PY{l+s+sd}{\PYZdq{}\PYZdq{}\PYZdq{}}
         \PY{l+s+sd}{    Computes the cost using the sigmoid cross entropy}
         \PY{l+s+sd}{    }
         \PY{l+s+sd}{    Arguments:}
         \PY{l+s+sd}{    logits \PYZhy{}\PYZhy{} vector containing z, output of the last linear unit (before the final sigmoid activation)}
         \PY{l+s+sd}{    labels \PYZhy{}\PYZhy{} vector of labels y (1 or 0) }
         \PY{l+s+sd}{    }
         \PY{l+s+sd}{    Note: What we\PYZsq{}ve been calling \PYZdq{}z\PYZdq{} and \PYZdq{}y\PYZdq{} in this class are respectively called \PYZdq{}logits\PYZdq{} and \PYZdq{}labels\PYZdq{} }
         \PY{l+s+sd}{    in the TensorFlow documentation. So logits will feed into z, and labels into y. }
         \PY{l+s+sd}{    }
         \PY{l+s+sd}{    Returns:}
         \PY{l+s+sd}{    cost \PYZhy{}\PYZhy{} runs the session of the cost (formula (2))}
         \PY{l+s+sd}{    \PYZdq{}\PYZdq{}\PYZdq{}}
             
             \PY{c+c1}{\PYZsh{}\PYZsh{}\PYZsh{} START CODE HERE \PYZsh{}\PYZsh{}\PYZsh{} }
             
             \PY{c+c1}{\PYZsh{} Create the placeholders for \PYZdq{}logits\PYZdq{} (z) and \PYZdq{}labels\PYZdq{} (y) (approx. 2 lines)}
             \PY{n}{z} \PY{o}{=} \PY{n}{tf}\PY{o}{.}\PY{n}{placeholder}\PY{p}{(}\PY{n}{tf}\PY{o}{.}\PY{n}{float32}\PY{p}{,}\PY{n}{name} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{z}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
             \PY{n}{y} \PY{o}{=} \PY{n}{tf}\PY{o}{.}\PY{n}{placeholder}\PY{p}{(}\PY{n}{tf}\PY{o}{.}\PY{n}{float32}\PY{p}{,}\PY{n}{name} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{y}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
             
             \PY{c+c1}{\PYZsh{} Use the loss function (approx. 1 line)}
             \PY{n}{cost} \PY{o}{=} \PY{n}{tf}\PY{o}{.}\PY{n}{nn}\PY{o}{.}\PY{n}{sigmoid\PYZus{}cross\PYZus{}entropy\PYZus{}with\PYZus{}logits}\PY{p}{(}\PY{n}{logits}\PY{o}{=}\PY{n}{z}\PY{p}{,}\PY{n}{labels}\PY{o}{=}\PY{n}{y}\PY{p}{)}
             
             \PY{c+c1}{\PYZsh{} Create a session (approx. 1 line). See method 1 above.}
             \PY{n}{sess} \PY{o}{=} \PY{n}{tf}\PY{o}{.}\PY{n}{Session}\PY{p}{(}\PY{p}{)}
             
             \PY{c+c1}{\PYZsh{} Run the session (approx. 1 line).}
             \PY{n}{cost} \PY{o}{=} \PY{n}{sess}\PY{o}{.}\PY{n}{run}\PY{p}{(}\PY{n}{cost}\PY{p}{,}\PY{n}{feed\PYZus{}dict}\PY{o}{=}\PY{p}{\PYZob{}}\PY{n}{z}\PY{p}{:}\PY{n}{logits}\PY{p}{,}\PY{n}{y}\PY{p}{:}\PY{n}{labels}\PY{p}{\PYZcb{}}\PY{p}{)}
             
             \PY{c+c1}{\PYZsh{} Close the session (approx. 1 line). See method 1 above.}
             \PY{n}{sess}\PY{o}{.}\PY{n}{close}\PY{p}{(}\PY{p}{)}
             
             \PY{c+c1}{\PYZsh{}\PYZsh{}\PYZsh{} END CODE HERE \PYZsh{}\PYZsh{}\PYZsh{}}
             
             \PY{k}{return} \PY{n}{cost}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}17}]:} \PY{n}{logits} \PY{o}{=} \PY{n}{sigmoid}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{l+m+mf}{0.2}\PY{p}{,}\PY{l+m+mf}{0.4}\PY{p}{,}\PY{l+m+mf}{0.7}\PY{p}{,}\PY{l+m+mf}{0.9}\PY{p}{]}\PY{p}{)}\PY{p}{)}
         \PY{n}{cost} \PY{o}{=} \PY{n}{cost}\PY{p}{(}\PY{n}{logits}\PY{p}{,} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}\PY{p}{)}
         \PY{k}{print} \PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{cost = }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{cost}\PY{p}{)}\PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
cost = [ 1.00538719  1.03664088  0.41385433  0.39956614]

    \end{Verbatim}

    ** Expected Output** :

\begin{verbatim}
<tr> 
    <td>
        **cost**
    </td>
    <td>
    [ 1.00538719  1.03664088  0.41385433  0.39956614]
    </td>
</tr>
\end{verbatim}

    \subsubsection{1.4 - Using One Hot
encodings}\label{using-one-hot-encodings}

Many times in deep learning you will have a y vector with numbers
ranging from 0 to C-1, where C is the number of classes. If C is for
example 4, then you might have the following y vector which you will
need to convert as follows:

This is called a "one hot" encoding, because in the converted
representation exactly one element of each column is "hot" (meaning set
to 1). To do this conversion in numpy, you might have to write a few
lines of code. In tensorflow, you can use one line of code:

\begin{itemize}
\tightlist
\item
  tf.one\_hot(labels, depth, axis)
\end{itemize}

\textbf{Exercise:} Implement the function below to take one vector of
labels and the total number of classes \(C\), and return the one hot
encoding. Use \texttt{tf.one\_hot()} to do this.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}48}]:} \PY{c+c1}{\PYZsh{} GRADED FUNCTION: one\PYZus{}hot\PYZus{}matrix}
         
         \PY{k}{def} \PY{n+nf}{one\PYZus{}hot\PYZus{}matrix}\PY{p}{(}\PY{n}{labels}\PY{p}{,} \PY{n}{C}\PY{p}{)}\PY{p}{:}
             \PY{l+s+sd}{\PYZdq{}\PYZdq{}\PYZdq{}}
         \PY{l+s+sd}{    Creates a matrix where the i\PYZhy{}th row corresponds to the ith class number and the jth column}
         \PY{l+s+sd}{                     corresponds to the jth training example. So if example j had a label i. Then entry (i,j) }
         \PY{l+s+sd}{                     will be 1. }
         \PY{l+s+sd}{                     }
         \PY{l+s+sd}{    Arguments:}
         \PY{l+s+sd}{    labels \PYZhy{}\PYZhy{} vector containing the labels }
         \PY{l+s+sd}{    C \PYZhy{}\PYZhy{} number of classes, the depth of the one hot dimension}
         \PY{l+s+sd}{    }
         \PY{l+s+sd}{    Returns: }
         \PY{l+s+sd}{    one\PYZus{}hot \PYZhy{}\PYZhy{} one hot matrix}
         \PY{l+s+sd}{    \PYZdq{}\PYZdq{}\PYZdq{}}
             
             \PY{c+c1}{\PYZsh{}\PYZsh{}\PYZsh{} START CODE HERE \PYZsh{}\PYZsh{}\PYZsh{}}
             
             \PY{c+c1}{\PYZsh{} Create a tf.constant equal to C (depth), name it \PYZsq{}C\PYZsq{}. (approx. 1 line)}
             \PY{n}{C} \PY{o}{=} \PY{n}{tf}\PY{o}{.}\PY{n}{constant}\PY{p}{(}\PY{n}{C}\PY{p}{,}\PY{n}{name}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{C}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
             
             \PY{c+c1}{\PYZsh{} Use tf.one\PYZus{}hot, be careful with the axis (approx. 1 line)}
             \PY{n}{one\PYZus{}hot\PYZus{}matrix} \PY{o}{=} \PY{n}{tf}\PY{o}{.}\PY{n}{one\PYZus{}hot}\PY{p}{(}\PY{n}{labels}\PY{p}{,} \PY{n}{C}\PY{p}{,}\PY{n}{axis}\PY{o}{=}\PY{l+m+mi}{0}\PY{p}{)}
             
             \PY{c+c1}{\PYZsh{} Create the session (approx. 1 line)}
             \PY{n}{sess} \PY{o}{=} \PY{n}{tf}\PY{o}{.}\PY{n}{Session}\PY{p}{(}\PY{p}{)}
             
             \PY{c+c1}{\PYZsh{} Run the session (approx. 1 line)}
             \PY{n}{one\PYZus{}hot} \PY{o}{=} \PY{n}{sess}\PY{o}{.}\PY{n}{run}\PY{p}{(}\PY{n}{one\PYZus{}hot\PYZus{}matrix}\PY{p}{)}
             
             \PY{c+c1}{\PYZsh{} Close the session (approx. 1 line). See method 1 above.}
             \PY{n}{sess}\PY{o}{.}\PY{n}{close}\PY{p}{(}\PY{p}{)}
             
             \PY{c+c1}{\PYZsh{}\PYZsh{}\PYZsh{} END CODE HERE \PYZsh{}\PYZsh{}\PYZsh{}}
             
             \PY{k}{return} \PY{n}{one\PYZus{}hot}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}49}]:} \PY{n}{labels} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{3}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}
         \PY{n}{one\PYZus{}hot} \PY{o}{=} \PY{n}{one\PYZus{}hot\PYZus{}matrix}\PY{p}{(}\PY{n}{labels}\PY{p}{,} \PY{n}{C} \PY{o}{=} \PY{l+m+mi}{4}\PY{p}{)}
         \PY{k}{print} \PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{one\PYZus{}hot = }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{one\PYZus{}hot}\PY{p}{)}\PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
one\_hot = [[ 0.  0.  0.  1.  0.  0.]
 [ 1.  0.  0.  0.  0.  1.]
 [ 0.  1.  0.  0.  1.  0.]
 [ 0.  0.  1.  0.  0.  0.]]

    \end{Verbatim}

    \textbf{Expected Output}:

\begin{verbatim}
<tr> 
    <td>
        **one_hot**
    </td>
    <td>
    [[ 0.  0.  0.  1.  0.  0.]
\end{verbatim}

{[} 1. 0. 0. 0. 0. 1.{]}{[} 0. 1. 0. 0. 1. 0.{]} {[} 0. 0. 1. 0. 0.
0.{]}{]}

\begin{verbatim}
</tr>
\end{verbatim}

    \subsubsection{1.5 - Initialize with zeros and
ones}\label{initialize-with-zeros-and-ones}

Now you will learn how to initialize a vector of zeros and ones. The
function you will be calling is \texttt{tf.ones()}. To initialize with
zeros you could use tf.zeros() instead. These functions take in a shape
and return an array of dimension shape full of zeros and ones
respectively.

\textbf{Exercise:} Implement the function below to take in a shape and
to return an array (of the shape's dimension of ones).

\begin{itemize}
\tightlist
\item
  tf.ones(shape)
\end{itemize}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}54}]:} \PY{c+c1}{\PYZsh{} GRADED FUNCTION: ones}
         
         \PY{k}{def} \PY{n+nf}{ones}\PY{p}{(}\PY{n}{shape}\PY{p}{)}\PY{p}{:}
             \PY{l+s+sd}{\PYZdq{}\PYZdq{}\PYZdq{}}
         \PY{l+s+sd}{    Creates an array of ones of dimension shape}
         \PY{l+s+sd}{    }
         \PY{l+s+sd}{    Arguments:}
         \PY{l+s+sd}{    shape \PYZhy{}\PYZhy{} shape of the array you want to create}
         \PY{l+s+sd}{        }
         \PY{l+s+sd}{    Returns: }
         \PY{l+s+sd}{    ones \PYZhy{}\PYZhy{} array containing only ones}
         \PY{l+s+sd}{    \PYZdq{}\PYZdq{}\PYZdq{}}
             
             \PY{c+c1}{\PYZsh{}\PYZsh{}\PYZsh{} START CODE HERE \PYZsh{}\PYZsh{}\PYZsh{}}
             
             \PY{c+c1}{\PYZsh{} Create \PYZdq{}ones\PYZdq{} tensor using tf.ones(...). (approx. 1 line)}
             \PY{n}{ones} \PY{o}{=} \PY{n}{tf}\PY{o}{.}\PY{n}{ones}\PY{p}{(}\PY{n}{shape}\PY{p}{,} \PY{n}{tf}\PY{o}{.}\PY{n}{float32}\PY{p}{)}
             
             \PY{c+c1}{\PYZsh{} Create the session (approx. 1 line)}
             \PY{n}{sess} \PY{o}{=} \PY{n}{tf}\PY{o}{.}\PY{n}{Session}\PY{p}{(}\PY{p}{)}
             
             \PY{c+c1}{\PYZsh{} Run the session to compute \PYZsq{}ones\PYZsq{} (approx. 1 line)}
             \PY{n}{ones} \PY{o}{=} \PY{n}{sess}\PY{o}{.}\PY{n}{run}\PY{p}{(}\PY{n}{ones}\PY{p}{)}
             
             \PY{c+c1}{\PYZsh{} Close the session (approx. 1 line). See method 1 above.}
             \PY{n}{sess}\PY{o}{.}\PY{n}{close}\PY{p}{(}\PY{p}{)}
             
             \PY{c+c1}{\PYZsh{}\PYZsh{}\PYZsh{} END CODE HERE \PYZsh{}\PYZsh{}\PYZsh{}}
             \PY{k}{return} \PY{n}{ones}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}55}]:} \PY{k}{print} \PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{ones = }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{ones}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{3}\PY{p}{]}\PY{p}{)}\PY{p}{)}\PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
ones = [ 1.  1.  1.]

    \end{Verbatim}

    \textbf{Expected Output:}

\begin{verbatim}
<tr> 
    <td>
        **ones**
    </td>
    <td>
    [ 1.  1.  1.]
    </td>
</tr>
\end{verbatim}

    \section{2 - Building your first neural network in
tensorflow}\label{building-your-first-neural-network-in-tensorflow}

In this part of the assignment you will build a neural network using
tensorflow. Remember that there are two parts to implement a tensorflow
model:

\begin{itemize}
\tightlist
\item
  Create the computation graph
\item
  Run the graph
\end{itemize}

Let's delve into the problem you'd like to solve!

\subsubsection{2.0 - Problem statement: SIGNS
Dataset}\label{problem-statement-signs-dataset}

One afternoon, with some friends we decided to teach our computers to
decipher sign language. We spent a few hours taking pictures in front of
a white wall and came up with the following dataset. It's now your job
to build an algorithm that would facilitate communications from a
speech-impaired person to someone who doesn't understand sign language.

\begin{itemize}
\tightlist
\item
  \textbf{Training set}: 1080 pictures (64 by 64 pixels) of signs
  representing numbers from 0 to 5 (180 pictures per number).
\item
  \textbf{Test set}: 120 pictures (64 by 64 pixels) of signs
  representing numbers from 0 to 5 (20 pictures per number).
\end{itemize}

Note that this is a subset of the SIGNS dataset. The complete dataset
contains many more signs.

Here are examples for each number, and how an explanation of how we
represent the labels. These are the original pictures, before we lowered
the image resolutoion to 64 by 64 pixels.

 \textbf{Figure 1}: SIGNS dataset

Run the following code to load the dataset.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}56}]:} \PY{c+c1}{\PYZsh{} Loading the dataset}
         \PY{n}{X\PYZus{}train\PYZus{}orig}\PY{p}{,} \PY{n}{Y\PYZus{}train\PYZus{}orig}\PY{p}{,} \PY{n}{X\PYZus{}test\PYZus{}orig}\PY{p}{,} \PY{n}{Y\PYZus{}test\PYZus{}orig}\PY{p}{,} \PY{n}{classes} \PY{o}{=} \PY{n}{load\PYZus{}dataset}\PY{p}{(}\PY{p}{)}
\end{Verbatim}

    Change the index below and run the cell to visualize some examples in
the dataset.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}60}]:} \PY{c+c1}{\PYZsh{} Example of a picture}
         \PY{n}{index} \PY{o}{=} \PY{l+m+mi}{42}
         \PY{n}{plt}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{X\PYZus{}train\PYZus{}orig}\PY{p}{[}\PY{n}{index}\PY{p}{]}\PY{p}{)}
         \PY{k}{print} \PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{y = }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{squeeze}\PY{p}{(}\PY{n}{Y\PYZus{}train\PYZus{}orig}\PY{p}{[}\PY{p}{:}\PY{p}{,} \PY{n}{index}\PY{p}{]}\PY{p}{)}\PY{p}{)}\PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
y = 0

    \end{Verbatim}

    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_35_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    As usual you flatten the image dataset, then normalize it by dividing by
255. On top of that, you will convert each label to a one-hot vector as
shown in Figure 1. Run the cell below to do so.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}62}]:} \PY{c+c1}{\PYZsh{} Flatten the training and test images}
         \PY{n}{X\PYZus{}train\PYZus{}flatten} \PY{o}{=} \PY{n}{X\PYZus{}train\PYZus{}orig}\PY{o}{.}\PY{n}{reshape}\PY{p}{(}\PY{n}{X\PYZus{}train\PYZus{}orig}\PY{o}{.}\PY{n}{shape}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{)}\PY{o}{.}\PY{n}{T}
         \PY{n}{X\PYZus{}test\PYZus{}flatten} \PY{o}{=} \PY{n}{X\PYZus{}test\PYZus{}orig}\PY{o}{.}\PY{n}{reshape}\PY{p}{(}\PY{n}{X\PYZus{}test\PYZus{}orig}\PY{o}{.}\PY{n}{shape}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{)}\PY{o}{.}\PY{n}{T}
         \PY{c+c1}{\PYZsh{} Normalize image vectors}
         \PY{n}{X\PYZus{}train} \PY{o}{=} \PY{n}{X\PYZus{}train\PYZus{}flatten}\PY{o}{/}\PY{l+m+mf}{255.}
         \PY{n}{X\PYZus{}test} \PY{o}{=} \PY{n}{X\PYZus{}test\PYZus{}flatten}\PY{o}{/}\PY{l+m+mf}{255.}
         \PY{c+c1}{\PYZsh{} Convert training and test labels to one hot matrices}
         \PY{n}{Y\PYZus{}train} \PY{o}{=} \PY{n}{convert\PYZus{}to\PYZus{}one\PYZus{}hot}\PY{p}{(}\PY{n}{Y\PYZus{}train\PYZus{}orig}\PY{p}{,} \PY{l+m+mi}{6}\PY{p}{)}
         \PY{n}{Y\PYZus{}test} \PY{o}{=} \PY{n}{convert\PYZus{}to\PYZus{}one\PYZus{}hot}\PY{p}{(}\PY{n}{Y\PYZus{}test\PYZus{}orig}\PY{p}{,} \PY{l+m+mi}{6}\PY{p}{)}
         
         \PY{k}{print} \PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{number of training examples = }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{X\PYZus{}train}\PY{o}{.}\PY{n}{shape}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}\PY{p}{)}
         \PY{k}{print} \PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{number of test examples = }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{X\PYZus{}test}\PY{o}{.}\PY{n}{shape}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}\PY{p}{)}
         \PY{k}{print} \PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{X\PYZus{}train shape: }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{X\PYZus{}train}\PY{o}{.}\PY{n}{shape}\PY{p}{)}\PY{p}{)}
         \PY{k}{print} \PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Y\PYZus{}train shape: }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{Y\PYZus{}train}\PY{o}{.}\PY{n}{shape}\PY{p}{)}\PY{p}{)}
         \PY{k}{print} \PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{X\PYZus{}test shape: }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{X\PYZus{}test}\PY{o}{.}\PY{n}{shape}\PY{p}{)}\PY{p}{)}
         \PY{k}{print} \PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Y\PYZus{}test shape: }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{Y\PYZus{}test}\PY{o}{.}\PY{n}{shape}\PY{p}{)}\PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
number of training examples = 1080
number of test examples = 120
X\_train shape: (12288, 1080)
Y\_train shape: (6, 1080)
X\_test shape: (12288, 120)
Y\_test shape: (6, 120)

    \end{Verbatim}

    \textbf{Note} that 12288 comes from \(64 \times 64 \times 3\). Each
image is square, 64 by 64 pixels, and 3 is for the RGB colors. Please
make sure all these shapes make sense to you before continuing.

    \textbf{Your goal} is to build an algorithm capable of recognizing a
sign with high accuracy. To do so, you are going to build a tensorflow
model that is almost the same as one you have previously built in numpy
for cat recognition (but now using a softmax output). It is a great
occasion to compare your numpy implementation to the tensorflow one.

\textbf{The model} is \emph{LINEAR -\textgreater{} RELU -\textgreater{}
LINEAR -\textgreater{} RELU -\textgreater{} LINEAR -\textgreater{}
SOFTMAX}. The SIGMOID output layer has been converted to a SOFTMAX. A
SOFTMAX layer generalizes SIGMOID to when there are more than two
classes.

    \subsubsection{2.1 - Create placeholders}\label{create-placeholders}

Your first task is to create placeholders for \texttt{X} and \texttt{Y}.
This will allow you to later pass your training data in when you run
your session.

\textbf{Exercise:} Implement the function below to create the
placeholders in tensorflow.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}82}]:} \PY{c+c1}{\PYZsh{} GRADED FUNCTION: create\PYZus{}placeholders}
         
         \PY{k}{def} \PY{n+nf}{create\PYZus{}placeholders}\PY{p}{(}\PY{n}{n\PYZus{}x}\PY{p}{,} \PY{n}{n\PYZus{}y}\PY{p}{)}\PY{p}{:}
             \PY{l+s+sd}{\PYZdq{}\PYZdq{}\PYZdq{}}
         \PY{l+s+sd}{    Creates the placeholders for the tensorflow session.}
         \PY{l+s+sd}{    }
         \PY{l+s+sd}{    Arguments:}
         \PY{l+s+sd}{    n\PYZus{}x \PYZhy{}\PYZhy{} scalar, size of an image vector (num\PYZus{}px * num\PYZus{}px = 64 * 64 * 3 = 12288)}
         \PY{l+s+sd}{    n\PYZus{}y \PYZhy{}\PYZhy{} scalar, number of classes (from 0 to 5, so \PYZhy{}\PYZgt{} 6)}
         \PY{l+s+sd}{    }
         \PY{l+s+sd}{    Returns:}
         \PY{l+s+sd}{    X \PYZhy{}\PYZhy{} placeholder for the data input, of shape [n\PYZus{}x, None] and dtype \PYZdq{}float\PYZdq{}}
         \PY{l+s+sd}{    Y \PYZhy{}\PYZhy{} placeholder for the input labels, of shape [n\PYZus{}y, None] and dtype \PYZdq{}float\PYZdq{}}
         \PY{l+s+sd}{    }
         \PY{l+s+sd}{    Tips:}
         \PY{l+s+sd}{    \PYZhy{} You will use None because it let\PYZsq{}s us be flexible on the number of examples you will for the placeholders.}
         \PY{l+s+sd}{      In fact, the number of examples during test/train is different.}
         \PY{l+s+sd}{    \PYZdq{}\PYZdq{}\PYZdq{}}
         
             \PY{c+c1}{\PYZsh{}\PYZsh{}\PYZsh{} START CODE HERE \PYZsh{}\PYZsh{}\PYZsh{} (approx. 2 lines)}
             \PY{n}{X} \PY{o}{=} \PY{n}{tf}\PY{o}{.}\PY{n}{placeholder}\PY{p}{(}\PY{n}{tf}\PY{o}{.}\PY{n}{float32}\PY{p}{,}\PY{n}{shape}\PY{o}{=}\PY{p}{(}\PY{n}{n\PYZus{}x}\PY{p}{,}\PY{n+nb+bp}{None}\PY{p}{)}\PY{p}{,}\PY{n}{name}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{x}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
             \PY{n}{Y} \PY{o}{=} \PY{n}{tf}\PY{o}{.}\PY{n}{placeholder}\PY{p}{(}\PY{n}{tf}\PY{o}{.}\PY{n}{float32}\PY{p}{,}\PY{n}{shape}\PY{o}{=}\PY{p}{(}\PY{n}{n\PYZus{}y}\PY{p}{,}\PY{n+nb+bp}{None}\PY{p}{)}\PY{p}{,}\PY{n}{name}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{y}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
             \PY{c+c1}{\PYZsh{}\PYZsh{}\PYZsh{} END CODE HERE \PYZsh{}\PYZsh{}\PYZsh{}}
             
             \PY{k}{return} \PY{n}{X}\PY{p}{,} \PY{n}{Y}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}83}]:} \PY{n}{X}\PY{p}{,} \PY{n}{Y} \PY{o}{=} \PY{n}{create\PYZus{}placeholders}\PY{p}{(}\PY{l+m+mi}{12288}\PY{p}{,} \PY{l+m+mi}{6}\PY{p}{)}
         \PY{k}{print} \PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{X = }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{X}\PY{p}{)}\PY{p}{)}
         \PY{k}{print} \PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Y = }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{Y}\PY{p}{)}\PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
X = Tensor("x\_1:0", shape=(12288, ?), dtype=float32)
Y = Tensor("y\_1:0", shape=(6, ?), dtype=float32)

    \end{Verbatim}

    \textbf{Expected Output}:

\begin{verbatim}
<tr> 
    <td>
        **X**
    </td>
    <td>
    Tensor("Placeholder_1:0", shape=(12288, ?), dtype=float32) (not necessarily Placeholder_1)
    </td>
</tr>
<tr> 
    <td>
        **Y**
    </td>
    <td>
    Tensor("Placeholder_2:0", shape=(10, ?), dtype=float32) (not necessarily Placeholder_2)
    </td>
</tr>
\end{verbatim}

    \subsubsection{2.2 - Initializing the
parameters}\label{initializing-the-parameters}

Your second task is to initialize the parameters in tensorflow.

\textbf{Exercise:} Implement the function below to initialize the
parameters in tensorflow. You are going use Xavier Initialization for
weights and Zero Initialization for biases. The shapes are given below.
As an example, to help you, for W1 and b1 you could use:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{W1 }\OperatorTok{=}\NormalTok{ tf.get_variable(}\StringTok{"W1"}\NormalTok{, [}\DecValTok{25}\NormalTok{,}\DecValTok{12288}\NormalTok{], initializer }\OperatorTok{=}\NormalTok{ tf.contrib.layers.xavier_initializer(seed }\OperatorTok{=} \DecValTok{1}\NormalTok{))}
\NormalTok{b1 }\OperatorTok{=}\NormalTok{ tf.get_variable(}\StringTok{"b1"}\NormalTok{, [}\DecValTok{25}\NormalTok{,}\DecValTok{1}\NormalTok{], initializer }\OperatorTok{=}\NormalTok{ tf.zeros_initializer())}
\end{Highlighting}
\end{Shaded}

Please use \texttt{seed\ =\ 1} to make sure your results match ours.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}84}]:} \PY{c+c1}{\PYZsh{} GRADED FUNCTION: initialize\PYZus{}parameters}
         
         \PY{k}{def} \PY{n+nf}{initialize\PYZus{}parameters}\PY{p}{(}\PY{p}{)}\PY{p}{:}
             \PY{l+s+sd}{\PYZdq{}\PYZdq{}\PYZdq{}}
         \PY{l+s+sd}{    Initializes parameters to build a neural network with tensorflow. The shapes are:}
         \PY{l+s+sd}{                        W1 : [25, 12288]}
         \PY{l+s+sd}{                        b1 : [25, 1]}
         \PY{l+s+sd}{                        W2 : [12, 25]}
         \PY{l+s+sd}{                        b2 : [12, 1]}
         \PY{l+s+sd}{                        W3 : [6, 12]}
         \PY{l+s+sd}{                        b3 : [6, 1]}
         \PY{l+s+sd}{    }
         \PY{l+s+sd}{    Returns:}
         \PY{l+s+sd}{    parameters \PYZhy{}\PYZhy{} a dictionary of tensors containing W1, b1, W2, b2, W3, b3}
         \PY{l+s+sd}{    \PYZdq{}\PYZdq{}\PYZdq{}}
             
             \PY{n}{tf}\PY{o}{.}\PY{n}{set\PYZus{}random\PYZus{}seed}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{)}                   \PY{c+c1}{\PYZsh{} so that your \PYZdq{}random\PYZdq{} numbers match ours}
                 
             \PY{c+c1}{\PYZsh{}\PYZsh{}\PYZsh{} START CODE HERE \PYZsh{}\PYZsh{}\PYZsh{} (approx. 6 lines of code)}
             \PY{n}{W1} \PY{o}{=} \PY{n}{tf}\PY{o}{.}\PY{n}{get\PYZus{}variable}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{W1}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{p}{[}\PY{l+m+mi}{25}\PY{p}{,}\PY{l+m+mi}{12288}\PY{p}{]}\PY{p}{,} \PY{n}{initializer} \PY{o}{=} \PY{n}{tf}\PY{o}{.}\PY{n}{contrib}\PY{o}{.}\PY{n}{layers}\PY{o}{.}\PY{n}{xavier\PYZus{}initializer}\PY{p}{(}\PY{n}{seed} \PY{o}{=} \PY{l+m+mi}{1}\PY{p}{)}\PY{p}{)}
             \PY{n}{b1} \PY{o}{=} \PY{n}{tf}\PY{o}{.}\PY{n}{get\PYZus{}variable}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{b1}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{p}{[}\PY{l+m+mi}{25}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,} \PY{n}{initializer} \PY{o}{=} \PY{n}{tf}\PY{o}{.}\PY{n}{zeros\PYZus{}initializer}\PY{p}{(}\PY{p}{)}\PY{p}{)}
             \PY{n}{W2} \PY{o}{=} \PY{n}{tf}\PY{o}{.}\PY{n}{get\PYZus{}variable}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{W2}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{p}{[}\PY{l+m+mi}{12}\PY{p}{,}\PY{l+m+mi}{25}\PY{p}{]}\PY{p}{,} \PY{n}{initializer} \PY{o}{=} \PY{n}{tf}\PY{o}{.}\PY{n}{contrib}\PY{o}{.}\PY{n}{layers}\PY{o}{.}\PY{n}{xavier\PYZus{}initializer}\PY{p}{(}\PY{n}{seed} \PY{o}{=} \PY{l+m+mi}{1}\PY{p}{)}\PY{p}{)}
             \PY{n}{b2} \PY{o}{=} \PY{n}{tf}\PY{o}{.}\PY{n}{get\PYZus{}variable}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{b2}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{p}{[}\PY{l+m+mi}{12}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,} \PY{n}{initializer} \PY{o}{=} \PY{n}{tf}\PY{o}{.}\PY{n}{zeros\PYZus{}initializer}\PY{p}{(}\PY{p}{)}\PY{p}{)}
             \PY{n}{W3} \PY{o}{=} \PY{n}{tf}\PY{o}{.}\PY{n}{get\PYZus{}variable}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{W3}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{p}{[}\PY{l+m+mi}{6}\PY{p}{,}\PY{l+m+mi}{12}\PY{p}{]}\PY{p}{,} \PY{n}{initializer} \PY{o}{=} \PY{n}{tf}\PY{o}{.}\PY{n}{contrib}\PY{o}{.}\PY{n}{layers}\PY{o}{.}\PY{n}{xavier\PYZus{}initializer}\PY{p}{(}\PY{n}{seed} \PY{o}{=} \PY{l+m+mi}{1}\PY{p}{)}\PY{p}{)}
             \PY{n}{b3} \PY{o}{=} \PY{n}{tf}\PY{o}{.}\PY{n}{get\PYZus{}variable}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{b3}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{p}{[}\PY{l+m+mi}{6}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,} \PY{n}{initializer} \PY{o}{=} \PY{n}{tf}\PY{o}{.}\PY{n}{zeros\PYZus{}initializer}\PY{p}{(}\PY{p}{)}\PY{p}{)}
             \PY{c+c1}{\PYZsh{}\PYZsh{}\PYZsh{} END CODE HERE \PYZsh{}\PYZsh{}\PYZsh{}}
         
             \PY{n}{parameters} \PY{o}{=} \PY{p}{\PYZob{}}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{W1}\PY{l+s+s2}{\PYZdq{}}\PY{p}{:} \PY{n}{W1}\PY{p}{,}
                           \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{b1}\PY{l+s+s2}{\PYZdq{}}\PY{p}{:} \PY{n}{b1}\PY{p}{,}
                           \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{W2}\PY{l+s+s2}{\PYZdq{}}\PY{p}{:} \PY{n}{W2}\PY{p}{,}
                           \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{b2}\PY{l+s+s2}{\PYZdq{}}\PY{p}{:} \PY{n}{b2}\PY{p}{,}
                           \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{W3}\PY{l+s+s2}{\PYZdq{}}\PY{p}{:} \PY{n}{W3}\PY{p}{,}
                           \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{b3}\PY{l+s+s2}{\PYZdq{}}\PY{p}{:} \PY{n}{b3}\PY{p}{\PYZcb{}}
             
             \PY{k}{return} \PY{n}{parameters}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}85}]:} \PY{n}{tf}\PY{o}{.}\PY{n}{reset\PYZus{}default\PYZus{}graph}\PY{p}{(}\PY{p}{)}
         \PY{k}{with} \PY{n}{tf}\PY{o}{.}\PY{n}{Session}\PY{p}{(}\PY{p}{)} \PY{k}{as} \PY{n}{sess}\PY{p}{:}
             \PY{n}{parameters} \PY{o}{=} \PY{n}{initialize\PYZus{}parameters}\PY{p}{(}\PY{p}{)}
             \PY{k}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{W1 = }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{parameters}\PY{p}{[}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{W1}\PY{l+s+s2}{\PYZdq{}}\PY{p}{]}\PY{p}{)}\PY{p}{)}
             \PY{k}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{b1 = }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{parameters}\PY{p}{[}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{b1}\PY{l+s+s2}{\PYZdq{}}\PY{p}{]}\PY{p}{)}\PY{p}{)}
             \PY{k}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{W2 = }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{parameters}\PY{p}{[}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{W2}\PY{l+s+s2}{\PYZdq{}}\PY{p}{]}\PY{p}{)}\PY{p}{)}
             \PY{k}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{b2 = }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{parameters}\PY{p}{[}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{b2}\PY{l+s+s2}{\PYZdq{}}\PY{p}{]}\PY{p}{)}\PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
W1 = <tf.Variable 'W1:0' shape=(25, 12288) dtype=float32\_ref>
b1 = <tf.Variable 'b1:0' shape=(25, 1) dtype=float32\_ref>
W2 = <tf.Variable 'W2:0' shape=(12, 25) dtype=float32\_ref>
b2 = <tf.Variable 'b2:0' shape=(12, 1) dtype=float32\_ref>

    \end{Verbatim}

    \textbf{Expected Output}:

\begin{verbatim}
<tr> 
    <td>
        **W1**
    </td>
    <td>
     < tf.Variable 'W1:0' shape=(25, 12288) dtype=float32_ref >
    </td>
</tr>
<tr> 
    <td>
        **b1**
    </td>
    <td>
    < tf.Variable 'b1:0' shape=(25, 1) dtype=float32_ref >
    </td>
</tr>
<tr> 
    <td>
        **W2**
    </td>
    <td>
    < tf.Variable 'W2:0' shape=(12, 25) dtype=float32_ref >
    </td>
</tr>
<tr> 
    <td>
        **b2**
    </td>
    <td>
    < tf.Variable 'b2:0' shape=(12, 1) dtype=float32_ref >
    </td>
</tr>
\end{verbatim}

    As expected, the parameters haven't been evaluated yet.

    \subsubsection{2.3 - Forward propagation in
tensorflow}\label{forward-propagation-in-tensorflow}

You will now implement the forward propagation module in tensorflow. The
function will take in a dictionary of parameters and it will complete
the forward pass. The functions you will be using are:

\begin{itemize}
\tightlist
\item
  \texttt{tf.add(...,...)} to do an addition
\item
  \texttt{tf.matmul(...,...)} to do a matrix multiplication
\item
  \texttt{tf.nn.relu(...)} to apply the ReLU activation
\end{itemize}

\textbf{Question:} Implement the forward pass of the neural network. We
commented for you the numpy equivalents so that you can compare the
tensorflow implementation to numpy. It is important to note that the
forward propagation stops at \texttt{z3}. The reason is that in
tensorflow the last linear layer output is given as input to the
function computing the loss. Therefore, you don't need \texttt{a3}!

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}86}]:} \PY{c+c1}{\PYZsh{} GRADED FUNCTION: forward\PYZus{}propagation}
         
         \PY{k}{def} \PY{n+nf}{forward\PYZus{}propagation}\PY{p}{(}\PY{n}{X}\PY{p}{,} \PY{n}{parameters}\PY{p}{)}\PY{p}{:}
             \PY{l+s+sd}{\PYZdq{}\PYZdq{}\PYZdq{}}
         \PY{l+s+sd}{    Implements the forward propagation for the model: LINEAR \PYZhy{}\PYZgt{} RELU \PYZhy{}\PYZgt{} LINEAR \PYZhy{}\PYZgt{} RELU \PYZhy{}\PYZgt{} LINEAR \PYZhy{}\PYZgt{} SOFTMAX}
         \PY{l+s+sd}{    }
         \PY{l+s+sd}{    Arguments:}
         \PY{l+s+sd}{    X \PYZhy{}\PYZhy{} input dataset placeholder, of shape (input size, number of examples)}
         \PY{l+s+sd}{    parameters \PYZhy{}\PYZhy{} python dictionary containing your parameters \PYZdq{}W1\PYZdq{}, \PYZdq{}b1\PYZdq{}, \PYZdq{}W2\PYZdq{}, \PYZdq{}b2\PYZdq{}, \PYZdq{}W3\PYZdq{}, \PYZdq{}b3\PYZdq{}}
         \PY{l+s+sd}{                  the shapes are given in initialize\PYZus{}parameters}
         
         \PY{l+s+sd}{    Returns:}
         \PY{l+s+sd}{    Z3 \PYZhy{}\PYZhy{} the output of the last LINEAR unit}
         \PY{l+s+sd}{    \PYZdq{}\PYZdq{}\PYZdq{}}
             
             \PY{c+c1}{\PYZsh{} Retrieve the parameters from the dictionary \PYZdq{}parameters\PYZdq{} }
             \PY{n}{W1} \PY{o}{=} \PY{n}{parameters}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{W1}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}
             \PY{n}{b1} \PY{o}{=} \PY{n}{parameters}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{b1}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}
             \PY{n}{W2} \PY{o}{=} \PY{n}{parameters}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{W2}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}
             \PY{n}{b2} \PY{o}{=} \PY{n}{parameters}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{b2}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}
             \PY{n}{W3} \PY{o}{=} \PY{n}{parameters}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{W3}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}
             \PY{n}{b3} \PY{o}{=} \PY{n}{parameters}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{b3}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}
             
             \PY{c+c1}{\PYZsh{}\PYZsh{}\PYZsh{} START CODE HERE \PYZsh{}\PYZsh{}\PYZsh{} (approx. 5 lines)              \PYZsh{} Numpy Equivalents:}
             \PY{n}{Z1} \PY{o}{=} \PY{n}{tf}\PY{o}{.}\PY{n}{add}\PY{p}{(}\PY{n}{tf}\PY{o}{.}\PY{n}{matmul}\PY{p}{(}\PY{n}{W1}\PY{p}{,}\PY{n}{X}\PY{p}{)}\PY{p}{,}\PY{n}{b1}\PY{p}{)}                        \PY{c+c1}{\PYZsh{} Z1 = np.dot(W1, X) + b1}
             \PY{n}{A1} \PY{o}{=} \PY{n}{tf}\PY{o}{.}\PY{n}{nn}\PY{o}{.}\PY{n}{relu}\PY{p}{(}\PY{n}{Z1}\PY{p}{)}                                    \PY{c+c1}{\PYZsh{} A1 = relu(Z1)}
             \PY{n}{Z2} \PY{o}{=} \PY{n}{tf}\PY{o}{.}\PY{n}{add}\PY{p}{(}\PY{n}{tf}\PY{o}{.}\PY{n}{matmul}\PY{p}{(}\PY{n}{W2}\PY{p}{,}\PY{n}{A1}\PY{p}{)}\PY{p}{,}\PY{n}{b2}\PY{p}{)}                       \PY{c+c1}{\PYZsh{} Z2 = np.dot(W2, a1) + b2}
             \PY{n}{A2} \PY{o}{=} \PY{n}{tf}\PY{o}{.}\PY{n}{nn}\PY{o}{.}\PY{n}{relu}\PY{p}{(}\PY{n}{Z2}\PY{p}{)}                                    \PY{c+c1}{\PYZsh{} A2 = relu(Z2)}
             \PY{n}{Z3} \PY{o}{=} \PY{n}{tf}\PY{o}{.}\PY{n}{add}\PY{p}{(}\PY{n}{tf}\PY{o}{.}\PY{n}{matmul}\PY{p}{(}\PY{n}{W3}\PY{p}{,}\PY{n}{A2}\PY{p}{)}\PY{p}{,}\PY{n}{b3}\PY{p}{)}                       \PY{c+c1}{\PYZsh{} Z3 = np.dot(W3,Z2) + b3}
             \PY{c+c1}{\PYZsh{}\PYZsh{}\PYZsh{} END CODE HERE \PYZsh{}\PYZsh{}\PYZsh{}}
             
             \PY{k}{return} \PY{n}{Z3}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}87}]:} \PY{n}{tf}\PY{o}{.}\PY{n}{reset\PYZus{}default\PYZus{}graph}\PY{p}{(}\PY{p}{)}
         
         \PY{k}{with} \PY{n}{tf}\PY{o}{.}\PY{n}{Session}\PY{p}{(}\PY{p}{)} \PY{k}{as} \PY{n}{sess}\PY{p}{:}
             \PY{n}{X}\PY{p}{,} \PY{n}{Y} \PY{o}{=} \PY{n}{create\PYZus{}placeholders}\PY{p}{(}\PY{l+m+mi}{12288}\PY{p}{,} \PY{l+m+mi}{6}\PY{p}{)}
             \PY{n}{parameters} \PY{o}{=} \PY{n}{initialize\PYZus{}parameters}\PY{p}{(}\PY{p}{)}
             \PY{n}{Z3} \PY{o}{=} \PY{n}{forward\PYZus{}propagation}\PY{p}{(}\PY{n}{X}\PY{p}{,} \PY{n}{parameters}\PY{p}{)}
             \PY{k}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Z3 = }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{Z3}\PY{p}{)}\PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Z3 = Tensor("Add\_2:0", shape=(6, ?), dtype=float32)

    \end{Verbatim}

    \textbf{Expected Output}:

\begin{verbatim}
<tr> 
    <td>
        **Z3**
    </td>
    <td>
    Tensor("Add_2:0", shape=(6, ?), dtype=float32)
    </td>
</tr>
\end{verbatim}

    You may have noticed that the forward propagation doesn't output any
cache. You will understand why below, when we get to brackpropagation.

    \subsubsection{2.4 Compute cost}\label{compute-cost}

As seen before, it is very easy to compute the cost using:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(logits }\OperatorTok{=}\NormalTok{ ..., labels }\OperatorTok{=}\NormalTok{ ...))}
\end{Highlighting}
\end{Shaded}

\textbf{Question}: Implement the cost function below. - It is important
to know that the "\texttt{logits}" and "\texttt{labels}" inputs of
\texttt{tf.nn.softmax\_cross\_entropy\_with\_logits} are expected to be
of shape (number of examples, num\_classes). We have thus transposed Z3
and Y for you. - Besides, \texttt{tf.reduce\_mean} basically does the
summation over the examples.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}88}]:} \PY{c+c1}{\PYZsh{} GRADED FUNCTION: compute\PYZus{}cost }
         
         \PY{k}{def} \PY{n+nf}{compute\PYZus{}cost}\PY{p}{(}\PY{n}{Z3}\PY{p}{,} \PY{n}{Y}\PY{p}{)}\PY{p}{:}
             \PY{l+s+sd}{\PYZdq{}\PYZdq{}\PYZdq{}}
         \PY{l+s+sd}{    Computes the cost}
         \PY{l+s+sd}{    }
         \PY{l+s+sd}{    Arguments:}
         \PY{l+s+sd}{    Z3 \PYZhy{}\PYZhy{} output of forward propagation (output of the last LINEAR unit), of shape (6, number of examples)}
         \PY{l+s+sd}{    Y \PYZhy{}\PYZhy{} \PYZdq{}true\PYZdq{} labels vector placeholder, same shape as Z3}
         \PY{l+s+sd}{    }
         \PY{l+s+sd}{    Returns:}
         \PY{l+s+sd}{    cost \PYZhy{} Tensor of the cost function}
         \PY{l+s+sd}{    \PYZdq{}\PYZdq{}\PYZdq{}}
             
             \PY{c+c1}{\PYZsh{} to fit the tensorflow requirement for tf.nn.softmax\PYZus{}cross\PYZus{}entropy\PYZus{}with\PYZus{}logits(...,...)}
             \PY{n}{logits} \PY{o}{=} \PY{n}{tf}\PY{o}{.}\PY{n}{transpose}\PY{p}{(}\PY{n}{Z3}\PY{p}{)}
             \PY{n}{labels} \PY{o}{=} \PY{n}{tf}\PY{o}{.}\PY{n}{transpose}\PY{p}{(}\PY{n}{Y}\PY{p}{)}
             
             \PY{c+c1}{\PYZsh{}\PYZsh{}\PYZsh{} START CODE HERE \PYZsh{}\PYZsh{}\PYZsh{} (1 line of code)}
             \PY{n}{cost} \PY{o}{=} \PY{n}{tf}\PY{o}{.}\PY{n}{reduce\PYZus{}mean}\PY{p}{(}\PY{n}{tf}\PY{o}{.}\PY{n}{nn}\PY{o}{.}\PY{n}{softmax\PYZus{}cross\PYZus{}entropy\PYZus{}with\PYZus{}logits}\PY{p}{(}\PY{n}{logits} \PY{o}{=} \PY{n}{logits}\PY{p}{,} \PY{n}{labels} \PY{o}{=} \PY{n}{labels}\PY{p}{)}\PY{p}{)}
             \PY{c+c1}{\PYZsh{}\PYZsh{}\PYZsh{} END CODE HERE \PYZsh{}\PYZsh{}\PYZsh{}}
             
             \PY{k}{return} \PY{n}{cost}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}89}]:} \PY{n}{tf}\PY{o}{.}\PY{n}{reset\PYZus{}default\PYZus{}graph}\PY{p}{(}\PY{p}{)}
         
         \PY{k}{with} \PY{n}{tf}\PY{o}{.}\PY{n}{Session}\PY{p}{(}\PY{p}{)} \PY{k}{as} \PY{n}{sess}\PY{p}{:}
             \PY{n}{X}\PY{p}{,} \PY{n}{Y} \PY{o}{=} \PY{n}{create\PYZus{}placeholders}\PY{p}{(}\PY{l+m+mi}{12288}\PY{p}{,} \PY{l+m+mi}{6}\PY{p}{)}
             \PY{n}{parameters} \PY{o}{=} \PY{n}{initialize\PYZus{}parameters}\PY{p}{(}\PY{p}{)}
             \PY{n}{Z3} \PY{o}{=} \PY{n}{forward\PYZus{}propagation}\PY{p}{(}\PY{n}{X}\PY{p}{,} \PY{n}{parameters}\PY{p}{)}
             \PY{n}{cost} \PY{o}{=} \PY{n}{compute\PYZus{}cost}\PY{p}{(}\PY{n}{Z3}\PY{p}{,} \PY{n}{Y}\PY{p}{)}
             \PY{k}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{cost = }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{cost}\PY{p}{)}\PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
cost = Tensor("Mean:0", shape=(), dtype=float32)

    \end{Verbatim}

    \textbf{Expected Output}:

\begin{verbatim}
<tr> 
    <td>
        **cost**
    </td>
    <td>
    Tensor("Mean:0", shape=(), dtype=float32)
    </td>
</tr>
\end{verbatim}

    \subsubsection{2.5 - Backward propagation \& parameter
updates}\label{backward-propagation-parameter-updates}

This is where you become grateful to programming frameworks. All the
backpropagation and the parameters update is taken care of in 1 line of
code. It is very easy to incorporate this line in the model.

After you compute the cost function. You will create an
"\texttt{optimizer}" object. You have to call this object along with the
cost when running the tf.session. When called, it will perform an
optimization on the given cost with the chosen method and learning rate.

For instance, for gradient descent the optimizer would be:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{optimizer }\OperatorTok{=}\NormalTok{ tf.train.GradientDescentOptimizer(learning_rate }\OperatorTok{=}\NormalTok{ learning_rate).minimize(cost)}
\end{Highlighting}
\end{Shaded}

To make the optimization you would do:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{_ , c }\OperatorTok{=}\NormalTok{ sess.run([optimizer, cost], feed_dict}\OperatorTok{=}\NormalTok{\{X: minibatch_X, Y: minibatch_Y\})}
\end{Highlighting}
\end{Shaded}

This computes the backpropagation by passing through the tensorflow
graph in the reverse order. From cost to inputs.

\textbf{Note} When coding, we often use \texttt{\_} as a "throwaway"
variable to store values that we won't need to use later. Here,
\texttt{\_} takes on the evaluated value of \texttt{optimizer}, which we
don't need (and \texttt{c} takes the value of the \texttt{cost}
variable).

    \subsubsection{2.6 - Building the model}\label{building-the-model}

Now, you will bring it all together!

\textbf{Exercise:} Implement the model. You will be calling the
functions you had previously implemented.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}90}]:} \PY{k}{def} \PY{n+nf}{model}\PY{p}{(}\PY{n}{X\PYZus{}train}\PY{p}{,} \PY{n}{Y\PYZus{}train}\PY{p}{,} \PY{n}{X\PYZus{}test}\PY{p}{,} \PY{n}{Y\PYZus{}test}\PY{p}{,} \PY{n}{learning\PYZus{}rate} \PY{o}{=} \PY{l+m+mf}{0.0001}\PY{p}{,}
                   \PY{n}{num\PYZus{}epochs} \PY{o}{=} \PY{l+m+mi}{1500}\PY{p}{,} \PY{n}{minibatch\PYZus{}size} \PY{o}{=} \PY{l+m+mi}{32}\PY{p}{,} \PY{n}{print\PYZus{}cost} \PY{o}{=} \PY{n+nb+bp}{True}\PY{p}{)}\PY{p}{:}
             \PY{l+s+sd}{\PYZdq{}\PYZdq{}\PYZdq{}}
         \PY{l+s+sd}{    Implements a three\PYZhy{}layer tensorflow neural network: LINEAR\PYZhy{}\PYZgt{}RELU\PYZhy{}\PYZgt{}LINEAR\PYZhy{}\PYZgt{}RELU\PYZhy{}\PYZgt{}LINEAR\PYZhy{}\PYZgt{}SOFTMAX.}
         \PY{l+s+sd}{    }
         \PY{l+s+sd}{    Arguments:}
         \PY{l+s+sd}{    X\PYZus{}train \PYZhy{}\PYZhy{} training set, of shape (input size = 12288, number of training examples = 1080)}
         \PY{l+s+sd}{    Y\PYZus{}train \PYZhy{}\PYZhy{} test set, of shape (output size = 6, number of training examples = 1080)}
         \PY{l+s+sd}{    X\PYZus{}test \PYZhy{}\PYZhy{} training set, of shape (input size = 12288, number of training examples = 120)}
         \PY{l+s+sd}{    Y\PYZus{}test \PYZhy{}\PYZhy{} test set, of shape (output size = 6, number of test examples = 120)}
         \PY{l+s+sd}{    learning\PYZus{}rate \PYZhy{}\PYZhy{} learning rate of the optimization}
         \PY{l+s+sd}{    num\PYZus{}epochs \PYZhy{}\PYZhy{} number of epochs of the optimization loop}
         \PY{l+s+sd}{    minibatch\PYZus{}size \PYZhy{}\PYZhy{} size of a minibatch}
         \PY{l+s+sd}{    print\PYZus{}cost \PYZhy{}\PYZhy{} True to print the cost every 100 epochs}
         \PY{l+s+sd}{    }
         \PY{l+s+sd}{    Returns:}
         \PY{l+s+sd}{    parameters \PYZhy{}\PYZhy{} parameters learnt by the model. They can then be used to predict.}
         \PY{l+s+sd}{    \PYZdq{}\PYZdq{}\PYZdq{}}
             
             \PY{n}{ops}\PY{o}{.}\PY{n}{reset\PYZus{}default\PYZus{}graph}\PY{p}{(}\PY{p}{)}                         \PY{c+c1}{\PYZsh{} to be able to rerun the model without overwriting tf variables}
             \PY{n}{tf}\PY{o}{.}\PY{n}{set\PYZus{}random\PYZus{}seed}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{)}                             \PY{c+c1}{\PYZsh{} to keep consistent results}
             \PY{n}{seed} \PY{o}{=} \PY{l+m+mi}{3}                                          \PY{c+c1}{\PYZsh{} to keep consistent results}
             \PY{p}{(}\PY{n}{n\PYZus{}x}\PY{p}{,} \PY{n}{m}\PY{p}{)} \PY{o}{=} \PY{n}{X\PYZus{}train}\PY{o}{.}\PY{n}{shape}                          \PY{c+c1}{\PYZsh{} (n\PYZus{}x: input size, m : number of examples in the train set)}
             \PY{n}{n\PYZus{}y} \PY{o}{=} \PY{n}{Y\PYZus{}train}\PY{o}{.}\PY{n}{shape}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}                            \PY{c+c1}{\PYZsh{} n\PYZus{}y : output size}
             \PY{n}{costs} \PY{o}{=} \PY{p}{[}\PY{p}{]}                                        \PY{c+c1}{\PYZsh{} To keep track of the cost}
             
             \PY{c+c1}{\PYZsh{} Create Placeholders of shape (n\PYZus{}x, n\PYZus{}y)}
             \PY{c+c1}{\PYZsh{}\PYZsh{}\PYZsh{} START CODE HERE \PYZsh{}\PYZsh{}\PYZsh{} (1 line)}
             \PY{n}{X}\PY{p}{,} \PY{n}{Y} \PY{o}{=} \PY{n}{create\PYZus{}placeholders}\PY{p}{(}\PY{n}{n\PYZus{}x}\PY{p}{,} \PY{n}{n\PYZus{}y}\PY{p}{)}
             \PY{c+c1}{\PYZsh{}\PYZsh{}\PYZsh{} END CODE HERE \PYZsh{}\PYZsh{}\PYZsh{}}
         
             \PY{c+c1}{\PYZsh{} Initialize parameters}
             \PY{c+c1}{\PYZsh{}\PYZsh{}\PYZsh{} START CODE HERE \PYZsh{}\PYZsh{}\PYZsh{} (1 line)}
             \PY{n}{parameters} \PY{o}{=} \PY{n}{initialize\PYZus{}parameters}\PY{p}{(}\PY{p}{)}
             \PY{c+c1}{\PYZsh{}\PYZsh{}\PYZsh{} END CODE HERE \PYZsh{}\PYZsh{}\PYZsh{}}
             
             \PY{c+c1}{\PYZsh{} Forward propagation: Build the forward propagation in the tensorflow graph}
             \PY{c+c1}{\PYZsh{}\PYZsh{}\PYZsh{} START CODE HERE \PYZsh{}\PYZsh{}\PYZsh{} (1 line)}
             \PY{n}{Z3} \PY{o}{=} \PY{n}{forward\PYZus{}propagation}\PY{p}{(}\PY{n}{X}\PY{o}{=}\PY{n}{X}\PY{p}{,}\PY{n}{parameters}\PY{o}{=}\PY{n}{parameters}\PY{p}{)}
             \PY{c+c1}{\PYZsh{}\PYZsh{}\PYZsh{} END CODE HERE \PYZsh{}\PYZsh{}\PYZsh{}}
             
             \PY{c+c1}{\PYZsh{} Cost function: Add cost function to tensorflow graph}
             \PY{c+c1}{\PYZsh{}\PYZsh{}\PYZsh{} START CODE HERE \PYZsh{}\PYZsh{}\PYZsh{} (1 line)}
             \PY{n}{cost} \PY{o}{=} \PY{n}{compute\PYZus{}cost}\PY{p}{(}\PY{n}{Z3}\PY{p}{,}\PY{n}{Y}\PY{p}{)}
             \PY{c+c1}{\PYZsh{}\PYZsh{}\PYZsh{} END CODE HERE \PYZsh{}\PYZsh{}\PYZsh{}}
             
             \PY{c+c1}{\PYZsh{} Backpropagation: Define the tensorflow optimizer. Use an AdamOptimizer.}
             \PY{c+c1}{\PYZsh{}\PYZsh{}\PYZsh{} START CODE HERE \PYZsh{}\PYZsh{}\PYZsh{} (1 line)}
             \PY{n}{optimizer} \PY{o}{=} \PY{n}{optimizer} \PY{o}{=} \PY{n}{tf}\PY{o}{.}\PY{n}{train}\PY{o}{.}\PY{n}{AdamOptimizer}\PY{p}{(}\PY{n}{learning\PYZus{}rate} \PY{o}{=} \PY{n}{learning\PYZus{}rate}\PY{p}{)}\PY{o}{.}\PY{n}{minimize}\PY{p}{(}\PY{n}{cost}\PY{p}{)}
             \PY{c+c1}{\PYZsh{}\PYZsh{}\PYZsh{} END CODE HERE \PYZsh{}\PYZsh{}\PYZsh{}}
             
             \PY{c+c1}{\PYZsh{} Initialize all the variables}
             \PY{n}{init} \PY{o}{=} \PY{n}{tf}\PY{o}{.}\PY{n}{global\PYZus{}variables\PYZus{}initializer}\PY{p}{(}\PY{p}{)}
         
             \PY{c+c1}{\PYZsh{} Start the session to compute the tensorflow graph}
             \PY{k}{with} \PY{n}{tf}\PY{o}{.}\PY{n}{Session}\PY{p}{(}\PY{p}{)} \PY{k}{as} \PY{n}{sess}\PY{p}{:}
                 
                 \PY{c+c1}{\PYZsh{} Run the initialization}
                 \PY{n}{sess}\PY{o}{.}\PY{n}{run}\PY{p}{(}\PY{n}{init}\PY{p}{)}
                 
                 \PY{c+c1}{\PYZsh{} Do the training loop}
                 \PY{k}{for} \PY{n}{epoch} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{num\PYZus{}epochs}\PY{p}{)}\PY{p}{:}
         
                     \PY{n}{epoch\PYZus{}cost} \PY{o}{=} \PY{l+m+mf}{0.}                       \PY{c+c1}{\PYZsh{} Defines a cost related to an epoch}
                     \PY{n}{num\PYZus{}minibatches} \PY{o}{=} \PY{n+nb}{int}\PY{p}{(}\PY{n}{m} \PY{o}{/} \PY{n}{minibatch\PYZus{}size}\PY{p}{)} \PY{c+c1}{\PYZsh{} number of minibatches of size minibatch\PYZus{}size in the train set}
                     \PY{n}{seed} \PY{o}{=} \PY{n}{seed} \PY{o}{+} \PY{l+m+mi}{1}
                     \PY{n}{minibatches} \PY{o}{=} \PY{n}{random\PYZus{}mini\PYZus{}batches}\PY{p}{(}\PY{n}{X\PYZus{}train}\PY{p}{,} \PY{n}{Y\PYZus{}train}\PY{p}{,} \PY{n}{minibatch\PYZus{}size}\PY{p}{,} \PY{n}{seed}\PY{p}{)}
         
                     \PY{k}{for} \PY{n}{minibatch} \PY{o+ow}{in} \PY{n}{minibatches}\PY{p}{:}
         
                         \PY{c+c1}{\PYZsh{} Select a minibatch}
                         \PY{p}{(}\PY{n}{minibatch\PYZus{}X}\PY{p}{,} \PY{n}{minibatch\PYZus{}Y}\PY{p}{)} \PY{o}{=} \PY{n}{minibatch}
                         
                         \PY{c+c1}{\PYZsh{} IMPORTANT: The line that runs the graph on a minibatch.}
                         \PY{c+c1}{\PYZsh{} Run the session to execute the \PYZdq{}optimizer\PYZdq{} and the \PYZdq{}cost\PYZdq{}, the feedict should contain a minibatch for (X,Y).}
                         \PY{c+c1}{\PYZsh{}\PYZsh{}\PYZsh{} START CODE HERE \PYZsh{}\PYZsh{}\PYZsh{} (1 line)}
                         \PY{n}{\PYZus{}} \PY{p}{,} \PY{n}{minibatch\PYZus{}cost} \PY{o}{=} \PY{n}{sess}\PY{o}{.}\PY{n}{run}\PY{p}{(}\PY{p}{[}\PY{n}{optimizer}\PY{p}{,} \PY{n}{cost}\PY{p}{]}\PY{p}{,} \PY{n}{feed\PYZus{}dict}\PY{o}{=}\PY{p}{\PYZob{}}\PY{n}{X}\PY{p}{:} \PY{n}{minibatch\PYZus{}X}\PY{p}{,} \PY{n}{Y}\PY{p}{:} \PY{n}{minibatch\PYZus{}Y}\PY{p}{\PYZcb{}}\PY{p}{)}
                         \PY{c+c1}{\PYZsh{}\PYZsh{}\PYZsh{} END CODE HERE \PYZsh{}\PYZsh{}\PYZsh{}}
                         
                         \PY{n}{epoch\PYZus{}cost} \PY{o}{+}\PY{o}{=} \PY{n}{minibatch\PYZus{}cost} \PY{o}{/} \PY{n}{num\PYZus{}minibatches}
         
                     \PY{c+c1}{\PYZsh{} Print the cost every epoch}
                     \PY{k}{if} \PY{n}{print\PYZus{}cost} \PY{o}{==} \PY{n+nb+bp}{True} \PY{o+ow}{and} \PY{n}{epoch} \PY{o}{\PYZpc{}} \PY{l+m+mi}{100} \PY{o}{==} \PY{l+m+mi}{0}\PY{p}{:}
                         \PY{k}{print} \PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Cost after epoch }\PY{l+s+si}{\PYZpc{}i}\PY{l+s+s2}{: }\PY{l+s+si}{\PYZpc{}f}\PY{l+s+s2}{\PYZdq{}} \PY{o}{\PYZpc{}} \PY{p}{(}\PY{n}{epoch}\PY{p}{,} \PY{n}{epoch\PYZus{}cost}\PY{p}{)}\PY{p}{)}
                     \PY{k}{if} \PY{n}{print\PYZus{}cost} \PY{o}{==} \PY{n+nb+bp}{True} \PY{o+ow}{and} \PY{n}{epoch} \PY{o}{\PYZpc{}} \PY{l+m+mi}{5} \PY{o}{==} \PY{l+m+mi}{0}\PY{p}{:}
                         \PY{n}{costs}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{epoch\PYZus{}cost}\PY{p}{)}
                         
                 \PY{c+c1}{\PYZsh{} plot the cost}
                 \PY{n}{plt}\PY{o}{.}\PY{n}{plot}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{squeeze}\PY{p}{(}\PY{n}{costs}\PY{p}{)}\PY{p}{)}
                 \PY{n}{plt}\PY{o}{.}\PY{n}{ylabel}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{cost}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
                 \PY{n}{plt}\PY{o}{.}\PY{n}{xlabel}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{iterations (per tens)}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
                 \PY{n}{plt}\PY{o}{.}\PY{n}{title}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Learning rate =}\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{learning\PYZus{}rate}\PY{p}{)}\PY{p}{)}
                 \PY{n}{plt}\PY{o}{.}\PY{n}{show}\PY{p}{(}\PY{p}{)}
         
                 \PY{c+c1}{\PYZsh{} lets save the parameters in a variable}
                 \PY{n}{parameters} \PY{o}{=} \PY{n}{sess}\PY{o}{.}\PY{n}{run}\PY{p}{(}\PY{n}{parameters}\PY{p}{)}
                 \PY{k}{print} \PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Parameters have been trained!}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
         
                 \PY{c+c1}{\PYZsh{} Calculate the correct predictions}
                 \PY{n}{correct\PYZus{}prediction} \PY{o}{=} \PY{n}{tf}\PY{o}{.}\PY{n}{equal}\PY{p}{(}\PY{n}{tf}\PY{o}{.}\PY{n}{argmax}\PY{p}{(}\PY{n}{Z3}\PY{p}{)}\PY{p}{,} \PY{n}{tf}\PY{o}{.}\PY{n}{argmax}\PY{p}{(}\PY{n}{Y}\PY{p}{)}\PY{p}{)}
         
                 \PY{c+c1}{\PYZsh{} Calculate accuracy on the test set}
                 \PY{n}{accuracy} \PY{o}{=} \PY{n}{tf}\PY{o}{.}\PY{n}{reduce\PYZus{}mean}\PY{p}{(}\PY{n}{tf}\PY{o}{.}\PY{n}{cast}\PY{p}{(}\PY{n}{correct\PYZus{}prediction}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{float}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}\PY{p}{)}
         
                 \PY{k}{print} \PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Train Accuracy:}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{accuracy}\PY{o}{.}\PY{n}{eval}\PY{p}{(}\PY{p}{\PYZob{}}\PY{n}{X}\PY{p}{:} \PY{n}{X\PYZus{}train}\PY{p}{,} \PY{n}{Y}\PY{p}{:} \PY{n}{Y\PYZus{}train}\PY{p}{\PYZcb{}}\PY{p}{)}\PY{p}{)}
                 \PY{k}{print} \PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Test Accuracy:}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{accuracy}\PY{o}{.}\PY{n}{eval}\PY{p}{(}\PY{p}{\PYZob{}}\PY{n}{X}\PY{p}{:} \PY{n}{X\PYZus{}test}\PY{p}{,} \PY{n}{Y}\PY{p}{:} \PY{n}{Y\PYZus{}test}\PY{p}{\PYZcb{}}\PY{p}{)}\PY{p}{)}
                 
                 \PY{k}{return} \PY{n}{parameters}
\end{Verbatim}

    Run the following cell to train your model! On our machine it takes
about 5 minutes. Your "Cost after epoch 100" should be 1.016458. If it's
not, don't waste time; interrupt the training by clicking on the square
(⬛) in the upper bar of the notebook, and try to correct your code. If
it is the correct cost, take a break and come back in 5 minutes!

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}91}]:} \PY{n}{parameters} \PY{o}{=} \PY{n}{model}\PY{p}{(}\PY{n}{X\PYZus{}train}\PY{p}{,} \PY{n}{Y\PYZus{}train}\PY{p}{,} \PY{n}{X\PYZus{}test}\PY{p}{,} \PY{n}{Y\PYZus{}test}\PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Cost after epoch 0: 1.855702
Cost after epoch 100: 1.016458
Cost after epoch 200: 0.733102
Cost after epoch 300: 0.572940
Cost after epoch 400: 0.468774
Cost after epoch 500: 0.381021
Cost after epoch 600: 0.313822
Cost after epoch 700: 0.254158
Cost after epoch 800: 0.203829
Cost after epoch 900: 0.166421
Cost after epoch 1000: 0.141486
Cost after epoch 1100: 0.107580
Cost after epoch 1200: 0.086270
Cost after epoch 1300: 0.059371
Cost after epoch 1400: 0.052228

    \end{Verbatim}

    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_62_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \begin{Verbatim}[commandchars=\\\{\}]
Parameters have been trained!
Train Accuracy: 0.999074
Test Accuracy: 0.716667

    \end{Verbatim}

    \textbf{Expected Output}:

\begin{verbatim}
<tr> 
    <td>
        **Train Accuracy**
    </td>
    <td>
    0.999074
    </td>
</tr>
<tr> 
    <td>
        **Test Accuracy**
    </td>
    <td>
    0.716667
    </td>
</tr>
\end{verbatim}

Amazing, your algorithm can recognize a sign representing a figure
between 0 and 5 with 71.7\% accuracy.

\textbf{Insights}: - Your model seems big enough to fit the training set
well. However, given the difference between train and test accuracy, you
could try to add L2 or dropout regularization to reduce overfitting. -
Think about the session as a block of code to train the model. Each time
you run the session on a minibatch, it trains the parameters. In total
you have run the session a large number of times (1500 epochs) until you
obtained well trained parameters.

    \subsubsection{2.7 - Test with your own image (optional / ungraded
exercise)}\label{test-with-your-own-image-optional-ungraded-exercise}

Congratulations on finishing this assignment. You can now take a picture
of your hand and see the output of your model. To do that: 1. Click on
"File" in the upper bar of this notebook, then click "Open" to go on
your Coursera Hub. 2. Add your image to this Jupyter Notebook's
directory, in the "images" folder 3. Write your image's name in the
following code 4. Run the code and check if the algorithm is right!

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}93}]:} \PY{k+kn}{import} \PY{n+nn}{scipy}
         \PY{k+kn}{from} \PY{n+nn}{PIL} \PY{k+kn}{import} \PY{n}{Image}
         \PY{k+kn}{from} \PY{n+nn}{scipy} \PY{k+kn}{import} \PY{n}{ndimage}
         
         \PY{c+c1}{\PYZsh{}\PYZsh{} START CODE HERE \PYZsh{}\PYZsh{} (PUT YOUR IMAGE NAME) }
         \PY{n}{my\PYZus{}image} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{thumbs\PYZus{}up.jpg}\PY{l+s+s2}{\PYZdq{}}
         \PY{c+c1}{\PYZsh{}\PYZsh{} END CODE HERE \PYZsh{}\PYZsh{}}
         
         \PY{c+c1}{\PYZsh{} We preprocess your image to fit your algorithm.}
         \PY{n}{fname} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{images/}\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n}{my\PYZus{}image}
         \PY{n}{image} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{n}{ndimage}\PY{o}{.}\PY{n}{imread}\PY{p}{(}\PY{n}{fname}\PY{p}{,} \PY{n}{flatten}\PY{o}{=}\PY{n+nb+bp}{False}\PY{p}{)}\PY{p}{)}
         \PY{n}{my\PYZus{}image} \PY{o}{=} \PY{n}{scipy}\PY{o}{.}\PY{n}{misc}\PY{o}{.}\PY{n}{imresize}\PY{p}{(}\PY{n}{image}\PY{p}{,} \PY{n}{size}\PY{o}{=}\PY{p}{(}\PY{l+m+mi}{64}\PY{p}{,}\PY{l+m+mi}{64}\PY{p}{)}\PY{p}{)}\PY{o}{.}\PY{n}{reshape}\PY{p}{(}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{64}\PY{o}{*}\PY{l+m+mi}{64}\PY{o}{*}\PY{l+m+mi}{3}\PY{p}{)}\PY{p}{)}\PY{o}{.}\PY{n}{T}
         \PY{n}{my\PYZus{}image\PYZus{}prediction} \PY{o}{=} \PY{n}{predict}\PY{p}{(}\PY{n}{my\PYZus{}image}\PY{p}{,} \PY{n}{parameters}\PY{p}{)}
         
         \PY{n}{plt}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{image}\PY{p}{)}
         \PY{k}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Your algorithm predicts: y = }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{squeeze}\PY{p}{(}\PY{n}{my\PYZus{}image\PYZus{}prediction}\PY{p}{)}\PY{p}{)}\PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Your algorithm predicts: y = 3

    \end{Verbatim}

    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_65_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    You indeed deserved a "thumbs-up" although as you can see the algorithm
seems to classify it incorrectly. The reason is that the training set
doesn't contain any "thumbs-up", so the model doesn't know how to deal
with it! We call that a "mismatched data distribution" and it is one of
the various of the next course on "Structuring Machine Learning
Projects".

     \textbf{What you should remember}: - Tensorflow is a programming
framework used in deep learning - The two main object classes in
tensorflow are Tensors and Operators. - When you code in tensorflow you
have to take the following steps: - Create a graph containing Tensors
(Variables, Placeholders ...) and Operations (tf.matmul, tf.add, ...) -
Create a session - Initialize the session - Run the session to execute
the graph - You can execute the graph multiple times as you've seen in
model() - The backpropagation and optimization is automatically done
when running the session on the "optimizer" object.


    % Add a bibliography block to the postdoc
    
    
    
    \end{document}
